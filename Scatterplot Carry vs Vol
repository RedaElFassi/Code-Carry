# =========================
# SCATTER — Carry (y>0) vs Delivered Vol (x) — caps & anti-densité
# =========================
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D

# --- abréviations & couleurs ---
country_shortcuts = {
    "France":"FR","Italy":"IT","Spain":"ES","Portugal":"PT","Belgium":"BE",
    "Austria":"AT","Finland":"FI","Greece":"GR","Netherlands":"NL","Germany":"DE",
    "Ireland":"IE","Slovenia":"SI"
}
color_map = {
    "France":"#1f77b4","Italy":"#17b7cf","Spain":"#17becf","Portugal":"#bcbd22",
    "Belgium":"#ff7f0e","Austria":"#d62728","Finland":"#2ca02c","Greece":"#9467bd",
    "Netherlands":"#e377c2","Germany":"#7f7f7f","Ireland":"#8c564b","Slovenia":"#7f7f7f"
}

# --- caps par pays (défaut 6) ---
DEFAULT_CAP = 6
COUNTRY_CAPS = {"Finland": 3, "Netherlands": 3}  # tu peux compléter si besoin

# ---------- placement de texte ----------
def _best_text_position(ax, x, y, text, taken_bboxes, pad=6):
    opts = [
        dict(ha='center', va='bottom', dx=0,  dy=+pad),
        dict(ha='center', va='top',    dx=0,  dy=-pad),
        dict(ha='left',   va='center', dx=+pad, dy=0),
        dict(ha='right',  va='center', dx=-pad, dy=0),
        dict(ha='left',   va='bottom', dx=+pad, dy=+pad),
        dict(ha='right',  va='bottom', dx=-pad, dy=+pad),
        dict(ha='left',   va='top',    dx=+pad, dy=-pad),
        dict(ha='right',  va='top',    dx=-pad, dy=-pad),
    ]
    fig = ax.figure; fig.canvas.draw()
    r = fig.canvas.get_renderer()
    for o in opts:
        a = ax.annotate(text, (x,y), textcoords="offset points",
                        xytext=(o['dx'],o['dy']), ha=o['ha'], va=o['va'], fontsize=9)
        bb = a.get_window_extent(renderer=r).expanded(1.03, 1.15)
        if not any(bb.overlaps(b) for b in taken_bboxes):
            taken_bboxes.append(bb); return
        a.remove()
    a = ax.annotate(text, (x,y), textcoords="offset points",
                    xytext=(opts[-1]['dx'],opts[-1]['dy']),
                    ha=opts[-1]['ha'], va=opts[-1]['va'], fontsize=9)
    taken_bboxes.append(a.get_window_extent(renderer=r))

# ---------- préparation des points ----------
def _prepare_points(df, key_col, dataset_kind):
    # si Country absent mais CountryPair présent ⇒ on prend la partie gauche
    if 'Country' not in df.columns and 'CountryPair' in df.columns:
        df = df.assign(Country=df['CountryPair'].astype(str).str.split('-', n=1, expand=True)[0])

    y_col = 'CarrySpread' if 'CarrySpread' in df.columns else 'Carry'
    use = [c for c in ['Country', key_col, 'Vol', y_col] if c in df.columns]
    d = df[use].copy()

    # cast num + nettoyage
    d['Vol'] = pd.to_numeric(d['Vol'], errors='coerce')
    d[y_col]  = pd.to_numeric(d[y_col],  errors='coerce')
    d = d.dropna(subset=['Country','Vol',y_col])

    # exclusions & filtre carry>0
    d = d[(d['Country'] != 'Greece') & (d['Country'] != 'Germany')]
    d = d[(d[y_col] > 0) & (d['Vol'] > 0)]

    # label
    def _lab(row):
        ab = country_shortcuts.get(row['Country'], row['Country'][:2].upper())
        k  = row[key_col]
        if key_col == 'Maturity':
            try:
                f = float(k); return f"{ab} {int(f)}y" if f.is_integer() else f"{ab} {f:g}y"
            except: return f"{ab} {k}"
        return f"{ab} {k}"
    d['Label'] = d.apply(_lab, axis=1)

    d = d.rename(columns={key_col:'Key', y_col:'CarryVal'})
    d['Color'] = d['Country'].map(color_map).fillna('black')
    d['CoV']   = d['CarryVal'] / d['Vol']
    return d

# ---------- priorités & “must keep” ----------
def _must_keep_FR_IT(df_pts):
    # force FR/IT sur 2/5/10/20 si la clé ressemble à une maturité
    targets = {2,5,10,20}
    idx = []
    for i,r in df_pts.iterrows():
        if r['Country'] in ('France','Italy'):
            try:
                if int(float(r['Key'])) in targets:
                    idx.append(i)
            except: pass
    return pd.Index(idx)

def _priority_score(df_pts):
    # ES/PT > FR/IT > autres
    return df_pts['Country'].map({'Spain':2,'Portugal':2,'France':1,'Italy':1}).fillna(0)

# ---------- clustering anti-densité ----------
def _cluster_thinning(df_pts, must_idx, pri_score,
                      eps=0.08, min_samples=4, cluster_cap_big=5, cluster_cap_small=3):
    """
    DBSCAN sur (Vol, CarryVal) normalisés ∈ [0,1]^2.
    - gros clusters -> on garde au plus cluster_cap_big points
    - petits clusters -> au plus cluster_cap_small
    Score = priorité (ES/PT/FR/IT) puis |CoV| décroissant.
    """
    if df_pts.empty: return df_pts

    # normalisation
    x = df_pts['Vol'].to_numpy(); y = df_pts['CarryVal'].to_numpy()
    x0,x1 = float(np.nanmin(x)), float(np.nanmax(x))
    y0,y1 = float(np.nanmin(y)), float(np.nanmax(y))
    xr,yr = max(x1-x0,1e-9), max(y1-y0,1e-9)
    X = np.column_stack(((x-x0)/xr, (y-y0)/yr))

    try:
        from sklearn.cluster import DBSCAN
        labels = DBSCAN(eps=eps, min_samples=min_samples).fit_predict(X)
    except Exception:
        # fallback: grille agressive
        gx = np.clip((X[:,0]*(18-1)).astype(int),0,17)
        gy = np.clip((X[:,1]*(10-1)).astype(int),0,9)
        labels = np.array([c[0]*10+c[1] for c in zip(gx,gy)])

    df = df_pts.copy()
    df['_cluster'] = labels
    df['_pri'] = pri_score
    df['_score'] = df['_pri']*10 + df['CoV'].abs()

    keep = set(must_idx.tolist())
    for cl, g in df[~df.index.isin(keep)].groupby('_cluster'):
        cap = cluster_cap_big if len(g) >= 10 else cluster_cap_small
        idx = g.sort_values('_score', ascending=False).head(cap).index
        keep |= set(idx.tolist())

    return df.loc[sorted(keep)].drop(columns=['_cluster','_pri','_score'])

# ---------- dernier filet : distance mini + caps par pays + cap global ----------
def _final_filter(df_pts, must_idx, max_points=40, min_norm_dist=0.06):
    if df_pts.empty: return df_pts

    # normalisation
    x = df_pts['Vol'].to_numpy(); y = df_pts['CarryVal'].to_numpy()
    x0,x1 = float(np.nanmin(x)), float(np.nanmax(x))
    y0,y1 = float(np.nanmin(y)), float(np.nanmax(y))
    xr,yr = max(x1-x0,1e-9), max(y1-y0,1e-9)

    # ordre: must d'abord, puis priorité, puis |CoV|
    pri = _priority_score(df_pts)
    order = pd.concat([
        df_pts.loc[must_idx],
        df_pts.drop(index=must_idx).sort_values(by=[pri.name, 'CoV'], ascending=[False, False])
    ]).drop_duplicates()

    kept, per_cty = [], {}
    for i,r in order.iterrows():
        c = r['Country']
        cap = COUNTRY_CAPS.get(c, DEFAULT_CAP)
        if i not in must_idx and per_cty.get(c,0) >= cap:
            continue
        xi = (r['Vol']-x0)/xr; yi = (r['CarryVal']-y0)/yr
        ok = True
        for j in kept:
            rj = df_pts.loc[j]
            xj = (rj['Vol']-x0)/xr; yj = (rj['CarryVal']-y0)/yr
            if np.hypot(xi-xj, yi-yj) < min_norm_dist:
                ok = False; break
        if ok:
            kept.append(i)
            per_cty[c] = per_cty.get(c,0)+1
            if len(kept) >= max_points: break

    return df_pts.loc[kept]

# ---------- moteur de plot ----------
def _plot_scatter(points, title,
                  max_points=40, eps=0.08, min_samples=4,
                  min_norm_dist=0.06):
    if points.empty:
        print("Aucun point à tracer."); return

    must = _must_keep_FR_IT(points)
    pri  = _priority_score(points)

    # 1) clustering anti-densité (sélection par zone)
    coarse = _cluster_thinning(points, must, pri,
                               eps=eps, min_samples=min_samples,
                               cluster_cap_big=5, cluster_cap_small=3)
    # 2) dernier filet: distance mini + caps pays + cap global
    selected = _final_filter(coarse, must,
                             max_points=max_points,
                             min_norm_dist=min_norm_dist)

    fig, ax = plt.subplots(figsize=(10,6))
    ax.axhline(0, color='grey', linewidth=0.8)
    ax.axvline(0, color='grey', linewidth=0.8)

    taken = []
    for _, r in selected.iterrows():
        ax.plot(r['Vol'], r['CarryVal'], marker='D', markersize=8,
                linestyle='None', color=r['Color'])
        _best_text_position(ax, r['Vol'], r['CarryVal'], r['Label'], taken)

    present = selected['Country'].unique().tolist()
    legend = [Line2D([0],[0], marker='D', color='w',
                     markerfacecolor=color_map.get(c,'black'), markersize=8,
                     label=country_shortcuts.get(c,c)) for c in present]
    ax.legend(handles=legend, title="Country", loc='upper right', fontsize=9)

    ax.set_xlabel("Delivered vol (bp)")
    ax.set_ylabel("Carry (bp) — positive only")
    ax.set_title(title, pad=14)
    ax.grid(True, alpha=0.25)
    plt.tight_layout(); plt.show()

# ---------- wrappers (1 DATAFRAME = 1 fonction) ----------
def plot_scatter_outright(df_outright):
    pts = _prepare_points(df_outright, 'Maturity', 'outright')
    _plot_scatter(pts, "Outright — Carry (y>0) vs Delivered Vol (x)")

def plot_scatter_spread(df_spread):
    pts = _prepare_points(df_spread, 'Maturity', 'spread')
    _plot_scatter(pts, "Spreads vs Germany — Carry (y>0) vs Delivered Vol (x)")

def plot_scatter_curve_outright(df_curve):
    pts = _prepare_points(df_curve, 'Box', 'curve_outright')
    _plot_scatter(pts, "Curve Outright — Carry (y>0) vs Delivered Vol (x)")

def plot_scatter_box(df_box):
    pts = _prepare_points(df_box, 'Box', 'box')
    _plot_scatter(pts, "Box vs Germany — Carry (y>0) vs Delivered Vol (x)")

def plot_scatter_fly_outright(df_fly_out):
    pts = _prepare_points(df_fly_out, 'Fly', 'fly_outright')
    _plot_scatter(pts, "Fly Outright — Carry (y>0) vs Delivered Vol (x)")

def plot_scatter_fly_box(df_fly_box):
    pts = _prepare_points(df_fly_box, 'Fly', 'fly_box')
    _plot_scatter(pts, "Fly vs Germany — Carry (y>0) vs Delivered Vol (x)")

