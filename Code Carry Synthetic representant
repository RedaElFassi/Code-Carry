# =========================
# FULL PIPELINE — Synth Representatives (Solution B robuste & cohérente)
# =========================
import pandas as pd
import numpy as np
from datetime import datetime

# ---------- PARAMS & INPUTS ATTENDUS ----------
country_list       = ["France","Italy","Spain","Portugal","Belgium","Austria","Finland","Greece"]  # <- SANS "Germany" pour l'affichage pivot
benchmark_country  = "Germany"
today              = pd.Timestamp.today().normalize()

# A fournir par ton environnement :
# bond_lists        = {country: [bond_name, ...], ...}
# carry_dataframes  = {country: DataFrame (dates x bonds)}
# yield_dataframes  = {country: DataFrame (dates x bonds)}

# ---------- Buckets & Combos ----------
Maturity_Buckets = {
    1:  (0.5, 1.5),
    2:  (1.8, 2.5),
    3:  (2.5, 3.5),
    4:  (3.5, 4.5),
    5:  (4.5, 5.5),
    7:  (6.5, 7.5),
    10: (9, 11),
    15: (13, 17),
    20: (18, 22),
    25: (23, 27),
    30: (27, 33),
}
maturity_order = [1,2,3,4,5,7,10,15,20,25,30]

box_order = ['2s10s','5s10s','2s30s','5s30s','10s30s','10s15s']
maturity_combinations = [(2,10),(5,10),(2,30),(5,30),(10,30),(10,15)]

fly_order = ['2s5s10s','5s7s10s','10s15s30s','5s10s30s']
fly_combinations = [(2,5,10),(5,7,10),(10,15,30),(5,10,30)]

# ---------- Helpers ----------
def years_to_maturity(bond_name: str):
    try:
        parts = bond_name.split()
        d = datetime.strptime(parts[3], "%d-%b-%Y")
        return (d - today).days / 365.25
    except Exception:
        return None

def get_maturity_bucket(bond_name: str):
    y = years_to_maturity(bond_name)
    if y is None: return None
    for b,(lo,hi) in Maturity_Buckets.items():
        if lo <= y <= hi: return b
    return None

def recent_enough(idx: pd.Index, max_age_days=7) -> bool:
    if len(idx)==0: return False
    return (today - pd.Timestamp(idx[-1])).days <= max_age_days

def rowwise_mean(series_list):
    """Moyenne ligne-par-ligne en ignorant les NaN (intersection souple)."""
    if not series_list: return pd.Series(dtype=float)
    df = pd.concat(series_list, axis=1)
    return df.mean(axis=1, skipna=True)

def tukey_filter_on_spot(carries, whisker=1.5):
    """Filtre IQR sur les carries spot fournis (array-like). Renvoie un masque keep bool."""
    arr = np.asarray(carries, dtype=float)
    if len(arr) <= 2:
        # trop peu de points -> garde tout (la logique 'positif d'abord' est appliquée avant)
        return np.ones_like(arr, dtype=bool)
    q1, q3 = np.nanpercentile(arr, [25, 75])
    iqr = q3 - q1
    lo, hi = q1 - whisker*iqr, q3 + whisker*iqr
    return (arr >= lo) & (arr <= hi)

def fly_weights(s, m, l):
    return {s: -1.0, m: 2.0, l: -1.0}

# ---------- Pré-filtrage colonnes utiles ----------
def filter_yield_bonds(df: pd.DataFrame, min_days: int = 63):
    keep = []
    for c in df.columns:
        s = df[c]
        if len(s.dropna()) >= min_days and s.iloc[-min_days:].isna().sum()==0 and recent_enough(s.dropna().index):
            keep.append(c)
    return df[keep], keep

def filter_carry_bonds(df: pd.DataFrame):
    keep = []
    for c in df.columns:
        s = df[c]
        if pd.isna(s.iloc[-1]): 
            continue
        if abs(s.iloc[-1]) > 15:  # hard cap carry spot
            continue
        if not recent_enough(s.dropna().index):
            continue
        keep.append(c)
    return df[keep], keep

def prepare_filtered_inputs(bond_lists, carry_dfs, yield_dfs):
    filtered_bond_lists, filtered_carry_dfs, filtered_yield_dfs = {}, {}, {}
    for c in set(list(bond_lists.keys()) + [benchmark_country]):
        if c not in bond_lists: 
            continue
        df_carry, carry_cols = filter_carry_bonds(carry_dfs[c])
        df_yield, yld_cols   = filter_yield_bonds(yield_dfs[c])
        common = sorted(set(carry_cols) & set(yld_cols))
        filtered_carry_dfs[c]   = df_carry[common]
        filtered_yield_dfs[c]   = df_yield[common]
        filtered_bond_lists[c]  = [b for b in bond_lists[c] if b in common]
    return filtered_bond_lists, filtered_carry_dfs, filtered_yield_dfs

# ---------- Représentants synthétiques par (Country, Bucket) ----------
def build_synthetic_representatives(bond_lists, carry_dfs, yield_dfs):
    """
    Pour chaque (country, bucket):
      - on récupère les bonds éligibles (|carry spot|<=15, fraîcheur ok)
      - priorité aux carries spot positifs s'il en existe; sinon on garde les négatifs
      - filtre intelligent via IQR sur le carry spot (Tukey)
      - série 'carry_synth' = moyenne ligne-par-ligne des carries des bonds retenus
      - série 'yield_synth' = moyenne ligne-par-ligne des yields des bonds retenus
    Retour:
      synth_carry[country][bucket] -> pd.Series
      synth_yield[country][bucket] -> pd.Series
      synth_meta[country][bucket]  -> dict(members=[...], spot=..., spot_count=..., had_positive=bool)
    """
    filtered_bond_lists, filtered_carry_dfs, filtered_yield_dfs = prepare_filtered_inputs(
        bond_lists, carry_dfs, yield_dfs
    )

    synth_carry = { }
    synth_yield = { }
    synth_meta  = { }

    countries_all = list(set(country_list + [benchmark_country]))
    for country in countries_all:
        if country not in filtered_bond_lists: 
            continue
        c_bonds = filtered_bond_lists[country]
        c_carry = filtered_carry_dfs[country]
        c_yld   = filtered_yield_dfs[country]

        # regroupe bonds par bucket
        by_bucket = {}
        for b in c_bonds:
            buck = get_maturity_bucket(b)
            if buck is None: 
                continue
            by_bucket.setdefault(buck, []).append(b)

        for buck, bonds in by_bucket.items():
            # carries spot sur ces bonds
            spots = []
            bonds_ok = []
            for b in bonds:
                s = c_carry[b]
                if pd.isna(s.iloc[-1]): 
                    continue
                if abs(s.iloc[-1]) > 15: 
                    continue
                if not recent_enough(s.dropna().index):
                    continue
                spots.append(float(s.iloc[-1]))
                bonds_ok.append(b)

            if not bonds_ok:
                continue

            spots = np.array(spots, dtype=float)

            # préférence aux positifs s'ils existent
            pos_mask = spots > 0
            if pos_mask.any():
                candidates = [b for b, keep in zip(bonds_ok, pos_mask) if keep]
                cand_spots = spots[pos_mask]
            else:
                # aucun positif -> on garde tous, et on prendra 'le moins pire' si trim supprime tout
                candidates = bonds_ok
                cand_spots = spots

            # filtre IQR (Tukey) sur les spots sélectionnés
            keep_mask = tukey_filter_on_spot(cand_spots, whisker=1.5)
            filtered_candidates = [b for b, keep in zip(candidates, keep_mask) if keep]

            # si rien après filtre -> fallback: prend le meilleur (max spot, même si négatif)
            if not filtered_candidates:
                best_idx = int(np.argmax(cand_spots))  # max même si négatif
                filtered_candidates = [candidates[best_idx]]

            # construit les séries synthétiques
            carry_series_list = [filtered_carry_dfs[country][b].dropna() for b in filtered_candidates]
            yld_series_list   = [filtered_yield_dfs[country][b].dropna()   for b in filtered_candidates]

            carry_synth = rowwise_mean(carry_series_list).dropna()
            yld_synth   = rowwise_mean(yld_series_list).dropna()

            # sanity caps à la fin (spot)
            if len(carry_synth) and abs(carry_synth.iloc[-1]) > 15:
                # si tout part en vrille -> skip
                continue

            synth_carry.setdefault(country, {})[buck] = carry_synth
            synth_yield.setdefault(country, {})[buck] = yld_synth
            synth_meta.setdefault(country, {})[buck]  = {
                "members": filtered_candidates,
                "spot": float(carry_synth.iloc[-1]) if len(carry_synth) else np.nan,
                "spot_count": len(filtered_candidates),
                "had_positive": bool(pos_mask.any())
            }

    return synth_carry, synth_yield, synth_meta

# ---------- 1) OUTRIGHT ----------
def compute_outright(bond_lists, carry_dfs, yield_dfs):
    synth_carry, synth_yield, _ = build_synthetic_representatives(bond_lists, carry_dfs, yield_dfs)
    rows = []
    for country in country_list + [benchmark_country]:
        if country not in synth_carry: 
            continue
        for m in sorted(synth_carry[country].keys()):
            cS = synth_carry[country][m]
            yS = synth_yield[country][m]
            if cS.empty or yS.empty: 
                continue
            carry_spot = cS.iloc[-1]
            if pd.isna(carry_spot) or abs(carry_spot) > 15: 
                continue
            if not (recent_enough(cS.index) and recent_enough(yS.index)): 
                continue
            # vol outright = std(63 derniers points du yield en bp)
            vol = (yS[-min(63, len(yS)):] * 100.0).std()
            if pd.isna(vol) or vol == 0: 
                continue
            # quantiles sur le carry outright sur 6m
            if len(cS) < 126: 
                continue
            q = cS[-126:].quantile([0,.25,.5,.75,1])
            wk = cS.iloc[-8] if len(cS) >= 8 else np.nan

            rows.append({
                "Country": country, "Maturity": m,
                "Carry": float(carry_spot), "Vol": float(vol), "CarryOverVol": float(carry_spot/vol),
                "Min": q.iloc[0], "Q25": q.iloc[1], "Q50": q.iloc[2], "Q75": q.iloc[3], "Max": q.iloc[4],
                "CarryOneWeekAgo": wk
            })
    df_outright = pd.DataFrame(rows)
    return df_outright

def pivot_outright(best_outright: pd.DataFrame):
    p = best_outright.pivot(index='Country', columns='Maturity', values=['Carry','Vol'])
    p.columns = p.columns.swaplevel(0,1)
    existing = [m for m in maturity_order if m in p.columns.levels[0]]
    p = p.reindex(columns=existing, level=0).sort_index(axis=1, level=0)
    return p.round(1)

# ---------- 2) SPREADS vs Germany ----------
def compute_spreads_from_synth(bond_lists, carry_dfs, yield_dfs):
    synth_carry, synth_yield, _ = build_synthetic_representatives(bond_lists, carry_dfs, yield_dfs)
    rows = []
    if benchmark_country not in synth_carry:
        return pd.DataFrame()

    for country in country_list:
        if country not in synth_carry: 
            continue
        for m in sorted(set(synth_carry[country].keys()) & set(synth_carry[benchmark_country].keys())):
            cC = synth_carry[country][m]; cD = synth_carry[benchmark_country][m]
            yC = synth_yield[country][m];  yD = synth_yield[benchmark_country][m]
            if any(s.empty for s in [cC,cD,yC,yD]): 
                continue
            # spots
            cs = float(cC.iloc[-1] - cD.iloc[-1])
            if abs(cs) > 15:  # hard cap carry spread
                continue
            # fraîcheur
            if not (recent_enough(cC.index) and recent_enough(cD.index) and recent_enough(yC.index) and recent_enough(yD.index)):
                continue
            # vol spread sur yield diff
            common_y = yC.index.intersection(yD.index)
            diff_y = (yC.reindex(common_y) - yD.reindex(common_y)).dropna() * 100.0
            if len(diff_y) < 40 or not recent_enough(diff_y.index):
                continue
            vol = diff_y[-min(63,len(diff_y)):].std()
            if pd.isna(vol) or vol==0: 
                continue
            # quantiles carry spread (hist)
            common_c = cC.index.intersection(cD.index)
            cdiff = (cC.reindex(common_c) - cD.reindex(common_c)).dropna()
            if len(cdiff) < 126: 
                continue
            q = cdiff[-126:].quantile([0,.25,.5,.75,1])
            wk = cdiff.iloc[-8] if len(cdiff) >= 8 else np.nan

            rows.append({
                "CountryPair": f"{country}-{benchmark_country}",
                "Country": country,
                "Maturity": m,
                "CarrySpread": cs, "Vol": float(vol), "CarryOverVol": float(cs/vol),
                "Min": q.iloc[0], "Q25": q.iloc[1], "Q50": q.iloc[2], "Q75": q.iloc[3], "Max": q.iloc[4],
                "CarryOneWeekAgo": wk
            })
    df_spread = pd.DataFrame(rows)
    return df_spread

def pivot_spread(best_spread: pd.DataFrame):
    # index = Country uniquement (pas "-Germany")
    p = best_spread.pivot(index='Country', columns='Maturity', values=['CarrySpread','Vol'])
    p.columns = p.columns.swaplevel(0,1)
    existing = [m for m in maturity_order if m in p.columns.levels[0]]
    p = p.reindex(columns=existing, level=0).sort_index(axis=1, level=0)
    return p.round(1)

# ---------- 3) CURVE OUTRIGHT (long - short) ----------
def compute_curve_outright_from_synth(bond_lists, carry_dfs, yield_dfs):
    synth_carry, synth_yield, _ = build_synthetic_representatives(bond_lists, carry_dfs, yield_dfs)
    rows = []
    for country in country_list + [benchmark_country]:
        if country not in synth_carry: 
            continue
        by_bucket_carry = synth_carry[country]
        by_bucket_yield = synth_yield[country]
        for s,l in maturity_combinations:
            if s not in by_bucket_carry or l not in by_bucket_carry:
                continue
            cS, cL = by_bucket_carry[s], by_bucket_carry[l]
            yS, yL = by_bucket_yield[s],  by_bucket_yield[l]
            if any(s_.empty for s_ in [cS,cL,yS,yL]): 
                continue
            carry_box = float(cL.iloc[-1] - cS.iloc[-1])
            if abs(carry_box) > 15: 
                continue
            if not (recent_enough(cS.index) and recent_enough(cL.index) and recent_enough(yS.index) and recent_enough(yL.index)):
                continue
            # vol sur diff de yields
            ydiff = (yL - yS).dropna() * 100.0
            if len(ydiff) < 40 or not recent_enough(ydiff.index): 
                continue
            vol = ydiff[-min(63,len(ydiff)):].std()
            if pd.isna(vol) or vol==0:
                continue
            # quantiles curve outright
            cdiff = (cL - cS).dropna()
            if len(cdiff) < 126: 
                continue
            q = cdiff[-126:].quantile([0,.25,.5,.75,1])
            wk = cdiff.iloc[-8] if len(cdiff) >= 8 else np.nan

            rows.append({
                "Country": country,
                "Box": f"{s}s{l}s",
                "Carry": carry_box, "Vol": float(vol), "CarryOverVol": float(carry_box/vol),
                "Min": q.iloc[0], "Q25": q.iloc[1], "Q50": q.iloc[2], "Q75": q.iloc[3], "Max": q.iloc[4],
                "CarryOneWeekAgo": wk
            })
    df_curve_outright = pd.DataFrame(rows)
    return df_curve_outright

def pivot_curve_outright(best_curve: pd.DataFrame):
    p = best_curve.pivot(index='Country', columns='Box', values=['Carry','Vol'])
    p.columns = p.columns.swaplevel(0,1)
    existing = [b for b in box_order if b in p.columns.levels[0]]
    p = p.reindex(columns=existing, level=0).sort_index(axis=1, level=0)
    return p.round(1)

# ---------- 4) BOXES vs Germany ----------
def compute_box_spreads_from_synth(bond_lists, carry_dfs, yield_dfs):
    synth_carry, synth_yield, _ = build_synthetic_representatives(bond_lists, carry_dfs, yield_dfs)
    rows = []
    if benchmark_country not in synth_carry:
        return pd.DataFrame()

    for country in country_list:
        if country not in synth_carry: 
            continue
        for s,l in maturity_combinations:
            # pays
            if s not in synth_carry[country] or l not in synth_carry[country]: 
                continue
            cS, cL = synth_carry[country][s], synth_carry[country][l]
            yS, yL = synth_yield[country][s],  synth_yield[country][l]
            # benchmark
            if s not in synth_carry[benchmark_country] or l not in synth_carry[benchmark_country]:
                continue
            dS, dL = synth_carry[benchmark_country][s], synth_carry[benchmark_country][l]
            yS_d, yL_d = synth_yield[benchmark_country][s], synth_yield[benchmark_country][l]

            if any(s_.empty for s_ in [cS,cL,yS,yL,dS,dL,yS_d,yL_d]): 
                continue
            carry_box = float((cL.iloc[-1]-cS.iloc[-1]) - (dL.iloc[-1]-dS.iloc[-1]))
            if abs(carry_box) > 15:
                continue
            if not all(recent_enough(x.index) for x in [cS,cL,yS,yL,dS,dL,yS_d,yL_d]): 
                continue

            # vol de box spread via yields
            common = yS.index & yL.index & yS_d.index & yL_d.index
            y_box = ((yL.reindex(common)-yL_d.reindex(common)) - (yS.reindex(common)-yS_d.reindex(common))).dropna()*100.0
            if len(y_box) < 40 or not recent_enough(y_box.index):
                continue
            vol = y_box[-min(63,len(y_box)):].std()
            if pd.isna(vol) or vol==0:
                continue

            # quantiles carry de la box (hist)
            common_c = cS.index & cL.index & dS.index & dL.index
            c_box_hist = ((cL.reindex(common_c)-dL.reindex(common_c)) - (cS.reindex(common_c)-dS.reindex(common_c))).dropna()
            if len(c_box_hist) < 126:
                continue
            q = c_box_hist[-126:].quantile([0,.25,.5,.75,1])
            wk = c_box_hist.iloc[-8] if len(c_box_hist) >= 8 else np.nan

            rows.append({
                "Country": country,
                "Box": f"{s}s{l}s",
                "Carry": carry_box, "Vol": float(vol), "CarryOverVol": float(carry_box/vol),
                "Min": q.iloc[0], "Q25": q.iloc[1], "Q50": q.iloc[2], "Q75": q.iloc[3], "Max": q.iloc[4],
                "CarryOneWeekAgo": wk
            })

    df_box = pd.DataFrame(rows)
    return df_box

def pivot_box(best_box: pd.DataFrame):
    p = best_box.pivot(index='Country', columns='Box', values=['Carry','Vol'])
    p.columns = p.columns.swaplevel(0,1)
    existing = [b for b in box_order if b in p.columns.levels[0]]
    p = p.reindex(columns=existing, level=0).sort_index(axis=1, level=0)
    return p.round(1)

# ---------- 5) FLY OUTRIGHT ----------
def compute_fly_outright_from_synth(bond_lists, carry_dfs, yield_dfs):
    synth_carry, synth_yield, _ = build_synthetic_representatives(bond_lists, carry_dfs, yield_dfs)
    rows = []
    for country in country_list + [benchmark_country]:
        if country not in synth_carry: 
            continue
        for s,m,l in fly_combinations:
            if not all(k in synth_carry[country] for k in [s,m,l]): 
                continue
            cS, cM, cL = synth_carry[country][s], synth_carry[country][m], synth_carry[country][l]
            yS, yM, yL = synth_yield[country][s],  synth_yield[country][m],  synth_yield[country][l]
            if any(s_.empty for s_ in [cS,cM,cL,yS,yM,yL]): 
                continue
            W = fly_weights(s,m,l)
            carry_fly = float(W[s]*cS.iloc[-1] + W[m]*cM.iloc[-1] + W[l]*cL.iloc[-1])
            if abs(carry_fly) > 15:
                continue
            if not all(recent_enough(x.index) for x in [cS,cM,cL,yS,yM,yL]): 
                continue

            y_fly = (W[s]*yS + W[m]*yM + W[l]*yL).dropna()*100.0
            if len(y_fly) < 40 or not recent_enough(y_fly.index):
                continue
            vol = y_fly[-min(63,len(y_fly)):].std()
            if pd.isna(vol) or vol==0:
                continue

            fly_hist = (W[s]*cS + W[m]*cM + W[l]*cL).dropna()
            if len(fly_hist) < 126:
                continue
            q = fly_hist[-126:].quantile([0,.25,.5,.75,1])
            wk = fly_hist.iloc[-8] if len(fly_hist) >= 8 else np.nan

            rows.append({
                "Country": country,
                "Fly": f"{s}s{m}s{l}s",
                "Carry": carry_fly, "Vol": float(vol), "CarryOverVol": float(carry_fly/vol),
                "Min": q.iloc[0], "Q25": q.iloc[1], "Q50": q.iloc[2], "Q75": q.iloc[3], "Max": q.iloc[4],
                "CarryOneWeekAgo": wk
            })
    df_fly_outright = pd.DataFrame(rows)
    return df_fly_outright

def pivot_fly_outright(best_fly_out: pd.DataFrame):
    p = best_fly_out.pivot(index='Country', columns='Fly', values=['Carry','Vol'])
    p.columns = p.columns.swaplevel(0,1)
    existing = [f for f in fly_order if f in p.columns.levels[0]]
    p = p.reindex(columns=existing, level=0).sort_index(axis=1, level=0)
    return p.round(1)

# ---------- 6) FLY BOXES vs Germany ----------
def compute_fly_box_spreads_from_synth(bond_lists, carry_dfs, yield_dfs):
    synth_carry, synth_yield, _ = build_synthetic_representatives(bond_lists, carry_dfs, yield_dfs)
    rows = []
    if benchmark_country not in synth_carry:
        return pd.DataFrame()

    for country in country_list:
        if country not in synth_carry: 
            continue
        for s,m,l in fly_combinations:
            # pays
            if not all(k in synth_carry[country] for k in [s,m,l]): 
                continue
            cS, cM, cL = synth_carry[country][s], synth_carry[country][m], synth_carry[country][l]
            yS, yM, yL = synth_yield[country][s],  synth_yield[country][m],  synth_yield[country][l]
            # benchmark
            if not all(k in synth_carry[benchmark_country] for k in [s,m,l]):
                continue
            dS, dM, dL = synth_carry[benchmark_country][s], synth_carry[benchmark_country][m], synth_carry[benchmark_country][l]
            yS_d, yM_d, yL_d = synth_yield[benchmark_country][s], synth_yield[benchmark_country][m], synth_yield[benchmark_country][l]
            if any(s_.empty for s_ in [cS,cM,cL,yS,yM,yL,dS,dM,dL,yS_d,yM_d,yL_d]): 
                continue

            W = fly_weights(s,m,l)
            carry_country = float(W[s]*cS.iloc[-1] + W[m]*cM.iloc[-1] + W[l]*cL.iloc[-1])
            carry_de      = float(W[s]*dS.iloc[-1] + W[m]*dM.iloc[-1] + W[l]*dL.iloc[-1])
            carry_fly_box = carry_country - carry_de
            if abs(carry_fly_box) > 15:
                continue
            if not all(recent_enough(x.index) for x in [cS,cM,cL,yS,yM,yL,dS,dM,dL,yS_d,yM_d,yL_d]): 
                continue

            common = yS.index & yM.index & yL.index & yS_d.index & yM_d.index & yL_d.index
            y_fly_box = (W[s]*(yS.reindex(common)-yS_d.reindex(common)) +
                         W[m]*(yM.reindex(common)-yM_d.reindex(common)) +
                         W[l]*(yL.reindex(common)-yL_d.reindex(common))).dropna()*100.0
            if len(y_fly_box) < 40 or not recent_enough(y_fly_box.index):
                continue
            vol = y_fly_box[-min(63,len(y_fly_box)):].std()
            if pd.isna(vol) or vol==0: 
                continue

            fly_hist_c = (W[s]*cS + W[m]*cM + W[l]*cL).dropna()
            fly_hist_d = (W[s]*dS + W[m]*dM + W[l]*dL).dropna()
            common_c = fly_hist_c.index.intersection(fly_hist_d.index)
            fly_box_hist = (fly_hist_c.reindex(common_c) - fly_hist_d.reindex(common_c)).dropna()
            if len(fly_box_hist) < 126:
                continue
            q = fly_box_hist[-126:].quantile([0,.25,.5,.75,1])
            wk = fly_box_hist.iloc[-8] if len(fly_box_hist) >= 8 else np.nan

            rows.append({
                "Country": country,
                "Fly": f"{s}s{m}s{l}s",
                "Carry": carry_fly_box, "Vol": float(vol), "CarryOverVol": float(carry_fly_box/vol),
                "Min": q.iloc[0], "Q25": q.iloc[1], "Q50": q.iloc[2], "Q75": q.iloc[3], "Max": q.iloc[4],
                "CarryOneWeekAgo": wk
            })

    df_fly_box = pd.DataFrame(rows)
    return df_fly_box

def pivot_fly_box(best_fly_box: pd.DataFrame):
    p = best_fly_box.pivot(index='Country', columns='Fly', values=['Carry','Vol'])
    p.columns = p.columns.swaplevel(0,1)
    existing = [f for f in fly_order if f in p.columns.levels[0]]
    p = p.reindex(columns=existing, level=0).sort_index(axis=1, level=0)
    return p.round(1)

# ---------- (Optionnel) remove_outliers_* ----------
# Ici, comme chaque bucket est déjà un représentant unique, on passe-through
def remove_outliers_and_average_outright(df_outright):  return df_outright.copy()
def remove_outliers_and_average_spread(df_spread):      return df_spread.copy()
def remove_outliers_and_average_curve(df_curve):        return df_curve.copy()
def remove_outliers_and_average_box(df_box):            return df_box.copy()
def remove_outliers_and_average_fly_outright(df_f):     return df_f.copy()
def remove_outliers_and_average_fly_box(df_fb):         return df_fb.copy()

# ---------- EXEMPLE D’APPELS (dé-commente pour run) ----------
# df_outright       = compute_outright(bond_lists, carry_dataframes, yield_dataframes)
# best_outright     = remove_outliers_and_average_outright(df_outright)
# pivot_df_out      = pivot_outright(best_outright)

# df_spread         = compute_spreads_from_synth(bond_lists, carry_dataframes, yield_dataframes)
# best_spread       = remove_outliers_and_average_spread(df_spread)
# pivot_df_spread   = pivot_spread(best_spread)

# df_curve_outright = compute_curve_outright_from_synth(bond_lists, carry_dataframes, yield_dataframes)
# best_curve        = remove_outliers_and_average_curve(df_curve_outright)
# pivot_df_curve    = pivot_curve_outright(best_curve)

# df_box            = compute_box_spreads_from_synth(bond_lists, carry_dataframes, yield_dataframes)
# best_box          = remove_outliers_and_average_box(df_box)
# pivot_df_box      = pivot_box(best_box)

# df_fly_outright   = compute_fly_outright_from_synth(bond_lists, carry_dataframes, yield_dataframes)
# best_fly_out      = remove_outliers_and_average_fly_outright(df_fly_outright)
# pivot_df_fly_out  = pivot_fly_outright(best_fly_out)

# df_fly_box        = compute_fly_box_spreads_from_synth(bond_lists, carry_dataframes, yield_dataframes)
# best_fly_box      = remove_outliers_and_average_fly_box(df_fly_box)
# pivot_df_fly_box  = pivot_fly_box(best_fly_box)

# print(pivot_df_out)
# print(pivot_df_spread)
# print(pivot_df_curve)
# print(pivot_df_box)
# print(pivot_df_fly_out)
# print(pivot_df_fly_box)


