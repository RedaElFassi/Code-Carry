# =========================================
# EMAIL "Carry Summaries" — 2-column HTML, inline-only images (no attachments),
# scatter = ta logique (couleurs, labels, filtrage, thinning),
# candlesticks = ton style (traits rouge/bleu, quantiles/médiane)
# =========================================
import smtplib, uuid
from io import BytesIO
from email.mime.multipart import MIMEMultipart
from email.mime.text   import MIMEText
from email.mime.image  import MIMEImage

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D

# ───────────────────────────────────────────────────────────────────────────────
# 0) PARAMS D’IMAGES POUR EMAIL (taille fixe, pas de crop)
# ───────────────────────────────────────────────────────────────────────────────
_DEF_DPI      = 160
_DEF_PX_W     = 640     # largeur fixe par colonne (~640 px) pour Outlook
_SCATTER_AR   = 0.66    # aspect ratio pour scatter (un peu + haut)
_CANDLE_AR    = 0.60    # aspect ratio pour candlesticks

def _prepare_fig_for_email(fig, px_width=_DEF_PX_W, aspect=_CANDLE_AR, dpi=_DEF_DPI):
    """Fixe la taille en pixels & évite bbox='tight' (Outlook coupe sinon)."""
    px_height = int(round(px_width * aspect))
    fig.set_dpi(dpi)
    fig.set_size_inches(px_width / dpi, px_height / dpi)
    try:
        fig.tight_layout()
    except Exception:
        pass
    return px_width, px_height

def _capture_current_figure():
    fig = plt.gcf()
    plt.close(fig)  # ne pas afficher, on intègre dans l'email
    return fig

# ───────────────────────────────────────────────────────────────────────────────
# 1) TON STYLE CANDLESTICK (traits rouge/bleu, mediane, q25-q75, min-max)
# ───────────────────────────────────────────────────────────────────────────────
def _draw_candles(ax, rows, x_key, x_is_bucket=True, title="Candlestick", xlabel="Maturity Buckets"):
    # cast propre pour éviter str/float
    cols_num = ["Min","Max","Q25","Q50","Q75","Vol","CarryOverVol","CarryOneWeekAgo"]
    for c in cols_num:
        if c in rows.columns:
            rows[c] = pd.to_numeric(rows[c], errors="coerce")

    label_added = False

    if not x_is_bucket:
        cats = rows[x_key].astype(str).tolist()
        order = list(dict.fromkeys(cats))
        xpos = {lab: i+1 for i, lab in enumerate(order)}
        ax.set_xticks(list(xpos.values()))
        ax.set_xticklabels(order, rotation=0)
    else:
        xpos = None

    for _, row in rows.iterrows():
        vol = row.get('Vol', np.nan)
        if pd.isna(vol) or vol <= 0:
            continue

        x = row[x_key] if x_is_bucket else xpos[str(row[x_key])]

        min_val      = row['Min']  / vol if pd.notna(row['Min'])  else np.nan
        max_val      = row['Max']  / vol if pd.notna(row['Max'])  else np.nan
        q1_val       = row['Q25']  / vol if pd.notna(row['Q25'])  else np.nan
        q3_val       = row['Q75']  / vol if pd.notna(row['Q75'])  else np.nan
        median_val   = row['Q50']  / vol if pd.notna(row['Q50'])  else np.nan
        current_val  = row['CarryOverVol']                     # déjà carry/vol
        one_week_val = row['CarryOneWeekAgo'] / vol if pd.notna(row['CarryOneWeekAgo']) else np.nan

        if any(pd.isna(v) for v in [min_val, max_val, q1_val, q3_val, median_val, current_val]):
            continue

        # tiges min↔max
        ax.plot([x, x], [min_val, max_val], color='black', marker='_', linewidth=2)
        # bande q25↔q75 (noir puis blanc pour un effet "épais")
        ax.plot([x, x], [q1_val, q3_val], color='black', linewidth=8, alpha=0.5)
        ax.plot([x, x], [q1_val, q3_val], color='white', linewidth=6, alpha=1.0)
        # médiane
        ax.plot([x, x], [median_val, median_val], color='black', marker='_', markersize=6)

        # Spot actuel = TRAIT rouge (pas de rond)
        ax.plot(x, current_val, color='red', marker='_', markersize=10,
                label='Current Value' if not label_added else "")

        # 1w ago = TRAIT bleu (pas de gros rond)
        if pd.notna(one_week_val):
            ax.plot(x, one_week_val, color='steelblue', marker='_', markersize=8,
                    label='1 Week ago' if not label_added else "")

        label_added = True

    ax.set_title(title)
    ax.set_ylabel("CarryOverVol")
    ax.set_xlabel(xlabel)
    ax.legend(loc='upper right')
    ax.grid(True)

# Wrappers candlesticks → retournent des FIGS (une par pays)
def candlestick_figs_outright(df_outright, countries=("France","Italy","Spain")):
    figs=[]
    df = df_outright.rename(columns={'Maturity':'Bucket'}) if 'Maturity' in df_outright.columns else df_outright
    for c in countries:
        sub = df[df['Country']==c]
        if sub.empty: continue
        fig, ax = plt.subplots()
        _draw_candles(ax, sub, x_key='Bucket', x_is_bucket=True,
                      title=f"{c} — Outright", xlabel="Maturity Buckets")
        _prepare_fig_for_email(fig, aspect=_CANDLE_AR)
        figs.append(_capture_current_figure())
    return figs

def candlestick_figs_spread(df_spread, countries=("France","Italy","Spain"), benchmark="Germany"):
    figs=[]
    df = df_spread.rename(columns={'Maturity':'Bucket'}) if 'Maturity' in df_spread.columns else df_spread
    for c in countries:
        pair = f"{c}-{benchmark}"
        sub = df[df['CountryPair']==pair]
        if sub.empty: continue
        fig, ax = plt.subplots()
        _draw_candles(ax, sub, x_key='Bucket', x_is_bucket=True,
                      title=f"{c} — Spread vs Germany", xlabel="Maturity Buckets")
        _prepare_fig_for_email(fig, aspect=_CANDLE_AR)
        figs.append(_capture_current_figure())
    return figs

def candlestick_figs_box_outright(df_curve, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_curve[df_curve['Country']==c]
        if sub.empty: continue
        fig, ax = plt.subplots()
        _draw_candles(ax, sub, x_key='Box', x_is_bucket=False,
                      title=f"{c} — Curve Outright", xlabel="Boxes")
        _prepare_fig_for_email(fig, aspect=_CANDLE_AR)
        figs.append(_capture_current_figure())
    return figs

def candlestick_figs_box_vs(df_box, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_box[df_box['Country']==c]
        if sub.empty: continue
        fig, ax = plt.subplots()
        _draw_candles(ax, sub, x_key='Box', x_is_bucket=False,
                      title=f"{c} — Box vs Germany", xlabel="Boxes")
        _prepare_fig_for_email(fig, aspect=_CANDLE_AR)
        figs.append(_capture_current_figure())
    return figs

def candlestick_figs_fly_outright(df_fly_out, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_fly_out[df_fly_out['Country']==c]
        if sub.empty: continue
        fig, ax = plt.subplots()
        _draw_candles(ax, sub, x_key='Fly', x_is_bucket=False,
                      title=f"{c} — Fly Outright", xlabel="Flies")
        _prepare_fig_for_email(fig, aspect=_CANDLE_AR)
        figs.append(_capture_current_figure())
    return figs

def candlestick_figs_fly_vs(df_fly_box, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_fly_box[df_fly_box['Country']==c]
        if sub.empty: continue
        fig, ax = plt.subplots()
        _draw_candles(ax, sub, x_key='Fly', x_is_bucket=False,
                      title=f"{c} — Fly vs Germany", xlabel="Flies")
        _prepare_fig_for_email(fig, aspect=_CANDLE_AR)
        figs.append(_capture_current_figure())
    return figs

# ───────────────────────────────────────────────────────────────────────────────
# 2) TA LOGIQUE SCATTER (couleurs + labels + filtrage + sélection intelligente)
# ───────────────────────────────────────────────────────────────────────────────
country_shortcuts = {
    "France":"FR","Italy":"IT","Spain":"ES","Portugal":"PT","Belgium":"BE",
    "Austria":"AT","Finland":"FI","Netherlands":"NL","Ireland":"IE","Slovakia":"SK","Slovenia":"SI",
    "Germany":"DE","Greece":"GR"
}
color_map = {
    "France":"#1f77b4","Italy":"#17becf","Spain":"#ff7f0e","Portugal":"#bcbd22",
    "Belgium":"#9467bd","Austria":"#d62728","Finland":"#2ca02c","Netherlands":"#e377c2",
    "Ireland":"#8c564b","Slovakia":"#7f7f7f","Slovenia":"#17b7cf"
}

def _candidate_positions(pad=6):
    return [
        (0,+pad,'center','bottom'), (0,-pad,'center','top'),
        (+pad,0,'left','center'),   (-pad,0,'right','center'),
        (+pad,+pad,'left','bottom'),(-pad,+pad,'right','bottom'),
        (+pad,-pad,'left','top'),   (-pad,-pad,'right','top')
    ]

def _best_text_position(ax, x, y, text, taken_bboxes, all_xy,
                        pad=6, r_near=0.14, w_overlap=12.0, w_density=1.5, w_out=5.0):
    fig = ax.figure
    fig.canvas.draw()
    r = fig.canvas.get_renderer()
    xv, yv = all_xy[:,0], all_xy[:,1]
    x0, x1 = float(np.nanmin(xv)), float(np.nanmax(xv))
    y0, y1 = float(np.nanmin(yv)), float(np.nanmax(yv))
    xr, yr = max(x1-x0,1e-9), max(y1-y0,1e-9)
    x_n, y_n = (x-x0)/xr, (y-y0)/yr
    R2 = r_near**2

    best_score, best_bb, best_ann = float('inf'), None, None
    for dx,dy,ha,va in _candidate_positions(pad):
        ann = ax.annotate(text, (x,y), textcoords="offset points", xytext=(dx,dy),
                          ha=ha, va=va, fontsize=9)
        bb = ann.get_window_extent(renderer=r).expanded(1.03, 1.15)

        overlap_pen = sum(bb.overlaps(tb) for tb in taken_bboxes)
        m = np.ones_like(xv, dtype=bool)
        if dx!=0: m &= (np.sign(xv-x)==np.sign(dx)) | np.isclose(xv,x)
        if dy!=0: m &= (np.sign(yv-y)==np.sign(dy)) | np.isclose(yv,y)
        xn = (xv[m]-x0)/xr; yn = (yv[m]-y0)/yr
        density_pen = float(np.sum((xn-x_n)**2 + (yn-y_n)**2 <= R2))

        xl, yl = ax.get_xlim(), ax.get_ylim()
        out_pen = 1.0 if (x<xl[0] or x>xl[1] or y<yl[0] or y>yl[1]) else 0.0

        score = w_overlap*overlap_pen + w_density*density_pen + w_out*out_pen
        if score < best_score:
            if best_ann is not None: best_ann.remove()
            best_score, best_bb, best_ann = score, bb, ann
        else:
            ann.remove()

    taken_bboxes.append(best_bb)

def _df_to_scatter_points(df, key_col, dataset_name):
    carry_col = 'Carry' if 'Carry' in df.columns else 'CarrySpread'
    cols = [c for c in ['Country', key_col, 'Vol', carry_col] if c in df.columns]
    d = df[cols].copy().rename(columns={key_col:'Key', carry_col:'CarryVal'})
    d = d.dropna(subset=['Country','Key','Vol','CarryVal'])
    d = d[np.isfinite(d['Vol']) & np.isfinite(d['CarryVal'])]

    d = d[~d['Country'].isin(['Greece'])]
    if dataset_name in ('outright','curve_outright','fly_outright'):
        d = d[~d['Country'].isin(['Germany'])]

    d = d[(d['Vol'] > 0) & (d['Vol'].abs() < 1e5) & (d['CarryVal'].abs() <= 40)]

    def _lab(row):
        c = country_shortcuts.get(row['Country'], row['Country'][:2].upper())
        k = row['Key']
        try:
            if float(k).is_integer():
                return f"{c} {int(float(k))}y"
        except Exception:
            pass
        return f"{c} {k}"
    d['Label'] = d.apply(_lab, axis=1)
    d['Color'] = d['Country'].map(color_map).fillna('black')
    d['CoV'] = d['CarryVal'] / d['Vol'].replace(0, np.nan)
    d = d.dropna(subset=['CoV'])
    return d

def _pick_top_for_country(df_pts, country, max_n=3, require_positive=True, prefer=(2,5,10,20)):
    sub = df_pts[df_pts['Country']==country].copy()
    if sub.empty: return sub
    sub['rankA'] = 2; sub['rankB'] = 0.0
    def _rank_key(k):
        try:
            kk = float(k)
            return (0 if int(kk) in prefer else 1, abs(kk-10))
        except Exception:
            return (2, 0.0)
    rk = sub['Key'].apply(_rank_key)
    sub['rankA'] = [a for a,_ in rk]; sub['rankB'] = [b for _,b in rk]
    if require_positive:
        pos = sub[sub['CarryVal'] > 0]
        if not pos.empty: sub = pos
    sub['absCoV'] = sub['CoV'].abs()
    sub = sub.sort_values(['rankA','rankB','absCoV'], ascending=[True, True, False])
    return sub.head(max_n).drop(columns=['rankA','rankB','absCoV'])

def _ensure_min_countries(selected, pool, min_countries=5,
                          prefer_order=('Spain','Portugal','Belgium','Austria','Finland','Netherlands','Ireland','Slovakia','Slovenia')):
    present = set(selected['Country'].unique())
    for c in prefer_order:
        if len(present) >= min_countries: break
        cand = pool[(pool['Country']==c) & (~pool.index.isin(selected.index)) & (pool['CarryVal']>0)]
        if not cand.empty:
            cand = cand.assign(absCoV=cand['CoV'].abs()).sort_values('absCoV', ascending=False).drop(columns='absCoV')
            pick = cand.iloc[[0]]
            selected = pd.concat([selected, pick], axis=0); present.add(c)
    return selected

def _grid_thinning(df_pts, must_keep_idx, grid=(16,10), max_per_cell=2, max_total=None, per_country_caps=None):
    if df_pts.empty: return df_pts
    x = df_pts['Vol'].values; y = df_pts['CarryVal'].values
    x0,x1 = np.nanmin(x), np.nanmax(x); y0,y1 = np.nanmin(y), np.nanmax(y)
    xr, yr = max(x1-x0,1e-6), max(y1-y0,1e-6)
    gx = np.clip(((x-x0)/xr*(grid[0]-1)).astype(int), 0, grid[0]-1)
    gy = np.clip(((y-y0)/yr*(grid[1]-1)).astype(int), 0, grid[1]-1)
    df = df_pts.copy(); df['_cell'] = list(zip(gx,gy))
    kept = set(must_keep_idx); caps = per_country_caps or {}
    df['absCoV'] = df['CoV'].abs()
    for cell, g in df[~df.index.isin(kept)].groupby('_cell'):
        g2 = g.sort_values('absCoV', ascending=False)
        taken = 0
        for idx,row in g2.iterrows():
            c = row['Country']
            if c in caps:
                already = sum(df.loc[list(kept)]['Country']==c)
                if already >= caps[c]: continue
            kept.add(idx); taken += 1
            if taken >= max_per_cell: break
    out = df.loc[sorted(kept)].drop(columns=['_cell','absCoV'])
    if (max_total is not None) and (len(out) > max_total):
        must = out.index.isin(must_keep_idx)
        rest = out[~must].copy()
        rest['absCoV'] = rest['CoV'].abs()
        rest = rest.sort_values('absCoV', ascending=False).drop(columns='absCoV')
        keep = list(out[must].index) + list(rest.index[:max_total - sum(must)])
        out = out.loc[keep]
    return out

def _select_points(points, dataset_name,
                   force_fr_it_min=3, min_countries=5, global_max_points=28, caps_extra=None):
    pts = points.copy()
    pts = pts[pts['CarryVal'] > 0]  # no negative carry
    must_rows = []
    for c in ('France','Italy'):
        pick = _pick_top_for_country(pts, c, max_n=force_fr_it_min, require_positive=True)
        must_rows.append(pick)
    must = pd.concat(must_rows, axis=0) if must_rows else pd.DataFrame(columns=pts.columns)
    selected = _ensure_min_countries(must.copy(), pts, min_countries=min_countries)
    caps = {'Finland':3, 'Netherlands':3}
    if caps_extra: caps.update(caps_extra)
    pool = pts[~pts.index.isin(selected.index)]
    union = pd.concat([selected, pool], axis=0).drop_duplicates()
    thinned = _grid_thinning(union, must_keep_idx=selected.index.tolist(),
                             grid=(18,11), max_per_cell=2,
                             max_total=global_max_points, per_country_caps=caps)
    thinned = _ensure_min_countries(thinned, pts, min_countries=min_countries)
    thinned['absCoV'] = thinned['CoV'].abs()
    thinned = thinned.sort_values(['Country','absCoV'], ascending=[True, False]).drop(columns='absCoV')
    return thinned

def _plot_scatter_generic(df, key_col, dataset_name, title, max_points_out=28):
    pts = _df_to_scatter_points(df, key_col, dataset_name)
    if pts.empty:
        fig, ax = plt.subplots()
        ax.text(0.5, 0.5, "Aucune donnée", ha='center', va='center')
        _prepare_fig_for_email(fig, aspect=_SCATTER_AR)
        return

    cap = max_points_out if dataset_name in ('outright','spread') else max(20, max_points_out-6)
    selected = _select_points(pts, dataset_name=dataset_name,
                              force_fr_it_min=3, min_countries=5,
                              global_max_points=cap, caps_extra=None)
    fig, ax = plt.subplots()
    ax.axhline(0, color='grey', linewidth=0.8)
    ax.axvline(0, color='grey', linewidth=0.8)

    taken_bboxes = []
    xy = selected[['Vol','CarryVal']].to_numpy()
    for _, row in selected.iterrows():
        ax.plot(row['Vol'], row['CarryVal'], marker='D', markersize=8,
                linestyle='None', color=row['Color'])
        _best_text_position(ax, row['Vol'], row['CarryVal'], row['Label'],
                            taken_bboxes=taken_bboxes, all_xy=xy,
                            pad=6, r_near=0.14, w_overlap=12.0, w_density=1.5, w_out=5.0)

    countries = selected['Country'].unique().tolist()
    legend_elems = [Line2D([0],[0], marker='D', color='w',
                           markerfacecolor=color_map.get(c,'black'), markersize=8,
                           label=country_shortcuts.get(c,c))
                    for c in countries]
    if legend_elems:
        ax.legend(handles=legend_elems, title="Country", loc='upper right', fontsize=9)

    ax.set_xlabel("Delivered vol (bp)")
    ax.set_ylabel("Carry (bp)")
    ax.set_title(title, pad=10)
    ax.grid(True, alpha=0.25)
    _prepare_fig_for_email(fig, aspect=_SCATTER_AR)
    plt.show()

# WRAPPERS scatter → retournent des FIGS (comme tu les vois dans Python)
def scatter_figure_outright(df_outright):
    _plot_scatter_generic(df_outright, key_col='Maturity', dataset_name='outright',
                          title="Outright — Carry (y) vs Delivered Vol (x)")
    return _capture_current_figure()

def scatter_figure_spread(df_spread):
    _plot_scatter_generic(df_spread, key_col='Maturity', dataset_name='spread',
                          title="Spreads vs Germany — Carry (y) vs Delivered Vol (x)")
    return _capture_current_figure()

def scatter_figure_box_outright(df_curve):
    _plot_scatter_generic(df_curve, key_col='Box', dataset_name='curve_outright',
                          title="Curve Outright — Carry (y) vs Delivered Vol (x)")
    return _capture_current_figure()

def scatter_figure_box_vs(df_box):
    _plot_scatter_generic(df_box, key_col='Box', dataset_name='box',
                          title="Box vs Germany — Carry (y) vs Delivered Vol (x)")
    return _capture_current_figure()

def scatter_figure_fly_outright(df_fly_out):
    _plot_scatter_generic(df_fly_out, key_col='Fly', dataset_name='fly_outright',
                          title="Fly Outright — Carry (y) vs Delivered Vol (x)")
    return _capture_current_figure()

def scatter_figure_fly_vs(df_fly_box):
    _plot_scatter_generic(df_fly_box, key_col='Fly', dataset_name='fly_box',
                          title="Fly vs Germany — Carry (y) vs Delivered Vol (x)")
    return _capture_current_figure()

# ───────────────────────────────────────────────────────────────────────────────
# 3) HTML HELPERS (tables compactes + images CID inline)
# ───────────────────────────────────────────────────────────────────────────────
def _df_to_html_table(df: pd.DataFrame, caption=None, max_rows=40, max_cols=24):
    if df is None or len(df)==0:
        return "<div style='font-style:italic;color:#666'>No data</div>"
    d = df.copy()
    if d.shape[0] > max_rows:
        d = pd.concat([d.head(max_rows),
                       pd.DataFrame([["..."]*d.shape[1]], columns=d.columns)], axis=0)
    if d.shape[1] > max_cols:
        d = d.iloc[:, :max_cols]
    html = d.to_html(border=1, index=True, justify='center')
    if caption:
        html = f"<div style='font:600 12px Arial;margin:6px 0 4px'>{caption}</div>{html}"
    html = html.replace("<table", "<table style='table-layout:fixed;border-collapse:collapse;font:10px Arial;width:100%'")
    html = html.replace("<th>", "<th style='padding:3px 5px;background:#f2f2f2;border:1px solid #ddd;word-wrap:break-word'>")
    html = html.replace("<td>", "<td style='padding:2px 4px;border:1px solid #eee;word-wrap:break-word'>")
    return html

def _fig_to_cid(root_msg, fig, cid_hint):
    """Attache l'image *sans* filename (pas de pièce jointe visible), renvoie cid et taille utilisée."""
    if fig is None:
        return "", 0, 0
    # la taille a déjà été fixée par _prepare_fig_for_email dans les wrappers
    buf = BytesIO()
    fig.savefig(buf, format='png', dpi=_DEF_DPI)  # pas de bbox='tight'
    buf.seek(0)
    img = MIMEImage(buf.read(), _subtype='png')
    cid = f"{cid_hint}-{uuid.uuid4().hex}@carry"
    img.add_header('Content-ID', f"<{cid}>")
    # IMPORTANT: NE PAS mettre de filename / Content-Disposition → pas d’attachement visible
    root_msg.attach(img)
    # on renvoie un tag <img> dimensionné exactement à _DEF_PX_W
    return cid, _DEF_PX_W, int(round(_DEF_PX_W * (_SCATTER_AR if "sc_" in cid_hint else _CANDLE_AR)))

def _img_tag(cid, width_px, height_px):
    return f"<img src='cid:{cid}' width='{width_px}' height='{height_px}' style='display:block;margin:8px 0'>"

def _col_html(title, table_html, scatter_img_html, cand_img_htmls):
    return f"""
    <div style="padding:10px">
      <div style="font:700 14px Arial;margin:0 0 6px 0">{title}</div>
      {table_html}
      {scatter_img_html}
      {''.join(cand_img_htmls)}
    </div>"""

def _two_col_row(left_html, right_html):
    return f"""
    <tr>
      <td valign="top" width="50%" style="width:50%;border-right:1px solid #e6e6e6">{left_html}</td>
      <td valign="top" width="50%" style="width:50%">{right_html}</td>
    </tr>"""

# ───────────────────────────────────────────────────────────────────────────────
# 4) BUILD FIGS + TABLES (utilise tes variables)
# ───────────────────────────────────────────────────────────────────────────────
def build_all_carry_figs_and_tables(
    best_outright, best_spread, best_curve, best_box, best_fly_out, best_fly_box,
    pivot_df_out, pivot_df_spread, pivot_df_curve, pivot_df_box, pivot_df_fly_out, pivot_df_fly_box,
    countries=("France","Italy","Spain")
):
    # scatters (figs)
    fig_sc_out   = scatter_figure_outright(best_outright)
    fig_sc_sp    = scatter_figure_spread(best_spread)
    fig_sc_box_o = scatter_figure_box_outright(best_curve)
    fig_sc_box_v = scatter_figure_box_vs(best_box)
    fig_sc_fly_o = scatter_figure_fly_outright(best_fly_out)
    fig_sc_fly_v = scatter_figure_fly_vs(best_fly_box)

    # candlesticks (listes de figs par pays)
    figs_out     = candlestick_figs_outright(best_outright, countries=countries)
    figs_spread  = candlestick_figs_spread(best_spread, countries=countries)
    figs_box_out = candlestick_figs_box_outright(best_curve, countries=countries)
    figs_box_vs  = candlestick_figs_box_vs(best_box, countries=countries)
    figs_fly_out = candlestick_figs_fly_outright(best_fly_out, countries=countries)
    figs_fly_vs  = candlestick_figs_fly_vs(best_fly_box, countries=countries)

    tables = dict(
        t_out     = _df_to_html_table(pivot_df_out,     caption="Pivot — Outright"),
        t_spread  = _df_to_html_table(pivot_df_spread,  caption="Pivot — Spread vs Germany"),
        t_box_out = _df_to_html_table(pivot_df_curve,   caption="Pivot — Curve Outright (Box)"),
        t_box_vs  = _df_to_html_table(pivot_df_box,     caption="Pivot — Box vs Germany"),
        t_fly_out = _df_to_html_table(pivot_df_fly_out, caption="Pivot — Fly Outright"),
        t_fly_vs  = _df_to_html_table(pivot_df_fly_box, caption="Pivot — Fly vs Germany"),
    )

    figs = dict(
        sc_out=fig_sc_out, sc_sp=fig_sc_sp,
        sc_box_o=fig_sc_box_o, sc_box_v=fig_sc_box_v,
        sc_fly_o=fig_sc_fly_o, sc_fly_v=fig_sc_fly_v,
        cand_out=figs_out, cand_sp=figs_spread,
        cand_box_o=figs_box_out, cand_box_v=figs_box_vs,
        cand_fly_o=figs_fly_out, cand_fly_v=figs_fly_vs,
    )
    return tables, figs

# ───────────────────────────────────────────────────────────────────────────────
# 5) SENDER — tout inline dans le corps du mail (zéro pièce jointe visible)
# ───────────────────────────────────────────────────────────────────────────────
def send_carry_email_using_your_vars(
    to_list,
    best_outright, best_spread, best_curve, best_box, best_fly_out, best_fly_box,
    pivot_df_out, pivot_df_spread, pivot_df_curve, pivot_df_box, pivot_df_fly_out, pivot_df_fly_box,
    sender="your.email@jpmorgan.com",
    subject="Carry Summaries",
    countries=("France","Italy","Spain")
):
    tables, figs = build_all_carry_figs_and_tables(
        best_outright, best_spread, best_curve, best_box, best_fly_out, best_fly_box,
        pivot_df_out, pivot_df_spread, pivot_df_curve, pivot_df_box, pivot_df_fly_out, pivot_df_fly_box,
        countries=countries
    )

    root = MIMEMultipart('related')
    root['Subject'] = subject
    root['From']    = sender
    root['To']      = ", ".join(to_list)
    alt  = MIMEMultipart('alternative')
    root.attach(alt)

    # Attache toutes les images (scatter + 3×candles/col), récupère les tags <img>
    def add_img(fig, hint):
        cid, w, h = _fig_to_cid(root, fig, hint)
        return _img_tag(cid, w, h) if cid else ""

    sc_out_img   = add_img(figs['sc_out'],   "sc_out")
    sc_sp_img    = add_img(figs['sc_sp'],    "sc_sp")
    sc_box_o_img = add_img(figs['sc_box_o'], "sc_box_o")
    sc_box_v_img = add_img(figs['sc_box_v'], "sc_box_v")
    sc_fly_o_img = add_img(figs['sc_fly_o'], "sc_fly_o")
    sc_fly_v_img = add_img(figs['sc_fly_v'], "sc_fly_v")

    cand_out_imgs   = [add_img(f, f"cand_out_{i+1}")   for i,f in enumerate(figs['cand_out']   or [])]
    cand_sp_imgs    = [add_img(f, f"cand_sp_{i+1}")    for i,f in enumerate(figs['cand_sp']    or [])]
    cand_box_o_imgs = [add_img(f, f"cand_box_o_{i+1}") for i,f in enumerate(figs['cand_box_o'] or [])]
    cand_box_v_imgs = [add_img(f, f"cand_box_v_{i+1}") for i,f in enumerate(figs['cand_box_v'] or [])]
    cand_fly_o_imgs = [add_img(f, f"cand_fly_o_{i+1}") for i,f in enumerate(figs['cand_fly_o'] or [])]
    cand_fly_v_imgs = [add_img(f, f"cand_fly_v_{i+1}") for i,f in enumerate(figs['cand_fly_v'] or [])]

    left1  = _col_html("Outright",             tables['t_out'],    sc_out_img,   cand_out_imgs)
    right1 = _col_html("Spread vs Germany",    tables['t_spread'], sc_sp_img,    cand_sp_imgs)
    left2  = _col_html("Curve Outright (Box)", tables['t_box_out'], sc_box_o_img, cand_box_o_imgs)
    right2 = _col_html("Box vs Germany",       tables['t_box_vs'],  sc_box_v_img, cand_box_v_imgs)
    left3  = _col_html("Fly Outright",         tables['t_fly_out'], sc_fly_o_img, cand_fly_o_imgs)
    right3 = _col_html("Fly vs Germany",       tables['t_fly_vs'],  sc_fly_v_img, cand_fly_v_imgs)

    row1 = _two_col_row(left1, right1)
    row2 = _two_col_row(left2, right2)
    row3 = _two_col_row(left3, right3)

    intro = """
    <div style="font:13px Arial">
      Hello Team,<br><br>
      Please find below the Carry Analysis.<br><br>
    </div>
    """

    html_body = f"""
    <html>
      <body style="margin:0;padding:0;background:#fff">
        <center>
        <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="1320"
               style="border-collapse:collapse;font:13px Arial">
          <tr><td colspan="2" style="padding:0 10px">{intro}</td></tr>

          <tr>
            <td colspan="2" style="font:700 16px Arial;padding:6px 10px;background:#f7f7f7;border-bottom:1px solid #e6e6e6">
              Outright (left) — vs Germany (right)
            </td>
          </tr>
          {row1}

          <tr><td colspan="2" style="height:14px"></td></tr>
          <tr>
            <td colspan="2" style="font:700 16px Arial;padding:6px 10px;background:#f7f7f7;border-bottom:1px solid #e6e6e6">
              Outright Curve (left) — Box vs Germany (right)
            </td>
          </tr>
          {row2}

          <tr><td colspan="2" style="height:14px"></td></tr>
          <tr>
            <td colspan="2" style="font:700 16px Arial;padding:6px 10px;background:#f7f7f7;border-bottom:1px solid #e6e6e6">
              Fly Outright (left) — Fly vs Germany (right)
            </td>
          </tr>
          {row3}
        </table>
        </center>
        <div style="height:12px"></div>
        <div style="font:11px Arial;color:#666;padding:0 10px">Generated automatically.</div>
      </body>
    </html>
    """
    alt.attach(MIMEText("Carry Summaries (HTML view required).", 'plain'))
    alt.attach(MIMEText(html_body, 'html'))

    # envoi — pas de login, inline only
    smtp = smtplib.SMTP('mailhost.jpmchase.net')
    smtp.sendmail(sender, to_list, root.as_string())
    smtp.quit()

# ───────────────────────────────────────────────────────────────────────────────
# 6) APPEL DIRECT — adapte juste les variables d’entrée et shoot
# ───────────────────────────────────────────────────────────────────────────────
if __name__ == "__main__":
    # ⚠️ Supposé déjà calculés dans ton pipeline:
    # best_outright, best_spread, best_curve, best_box, best_fly_out, best_fly_box
    # pivot_df_out, pivot_df_spread, pivot_df_curve, pivot_df_box, pivot_df_fly_out, pivot_df_fly_box

    # Exemple minimal (dé-commente et adapte):
    # to = ["team@jpmorgan.com"]
    # send_carry_email_using_your_vars(
    #     to_list=to,
    #     best_outright=best_outright,
    #     best_spread=best_spread,
    #     best_curve=best_curve,
    #     best_box=best_box,
    #     best_fly_out=best_fly_out,
    #     best_fly_box=best_fly_box,
    #     pivot_df_out=pivot_df_out,
    #     pivot_df_spread=pivot_df_spread,
    #     pivot_df_curve=pivot_df_curve,
    #     pivot_df_box=pivot_df_box,
    #     pivot_df_fly_out=pivot_df_fly_out,
    #     pivot_df_fly_box=pivot_df_fly_box,
    #     sender="your.email@jpmorgan.com",
    #     subject="Carry Summaries",
    #     countries=("France","Italy","Spain")
    # )
    pass


