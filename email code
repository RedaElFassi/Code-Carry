# =========================================
# Carry email — INLINE (no attachments), 2-cols, figures identiques à l’écran
# =========================================
import smtplib, uuid, math
from io import BytesIO
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D

# ========== CONFIG TAILLE IMAGES (stable pour Outlook) ==========
_DEF_DPI = 160
_DEF_PX_W = 640          # largeur par colonne
_DEF_ASPECT = 0.60       # hauteur = largeur * aspect  (≈ 384 px)

def _prepare_fig_for_email(fig, px_width=_DEF_PX_W, aspect=_DEF_ASPECT, dpi=_DEF_DPI):
    px_height = int(round(px_width * aspect))
    fig.set_dpi(dpi)
    fig.set_size_inches(px_width / dpi, px_height / dpi)
    try:
        fig.tight_layout()
    except Exception:
        pass
    return px_width, px_height

def _fig_to_cid(root_msg, fig, cid_hint, px_width=_DEF_PX_W, aspect=_DEF_ASPECT, dpi=_DEF_DPI):
    """Sauve la fig telle quelle, l’attache en inline (sans filename), renvoie (cid, w, h)."""
    if fig is None:
        return "", 0, 0
    w, h = _prepare_fig_for_email(fig, px_width=px_width, aspect=aspect, dpi=dpi)
    buf = BytesIO()
    # IMPORTANT: pas de bbox='tight' -> Outlook ne croppe pas
    fig.savefig(buf, format='png', dpi=dpi)
    buf.seek(0)
    img = MIMEImage(buf.read(), _subtype='png')
    cid = f"{cid_hint}-{uuid.uuid4().hex}@carry"
    img.add_header('Content-ID', f"<{cid}>")
    # AUCUNE 'Content-Disposition' / filename => n'apparait pas en pièce jointe
    root_msg.attach(img)
    return cid, w, h

def _img_tag(cid, width_px, height_px):
    return f"<img src='cid:{cid}' width='{width_px}' height='{height_px}' style='display:block;margin:8px 0'>"

# ========== TABLE HTML COMPACTE ==========
def _df_to_html_table(df: pd.DataFrame, caption=None, max_rows=40, max_cols=20):
    if df is None or len(df) == 0:
        return "<div style='font-style:italic;color:#666'>No data</div>"
    d = df.copy()
    if d.shape[0] > max_rows:
        d = pd.concat([d.head(max_rows),
                       pd.DataFrame([["..."]*d.shape[1]], columns=d.columns)], axis=0)
    if d.shape[1] > max_cols:
        d = d.iloc[:, :max_cols]
    html = d.to_html(border=1, index=True, justify='center')
    if caption:
        html = f"<div style='font:600 12px Arial;margin:6px 0 4px'>{caption}</div>{html}"
    html = html.replace("<table", "<table style='table-layout:fixed;border-collapse:collapse;font:10px Arial;width:100%'")
    html = html.replace("<th>", "<th style='padding:3px 5px;background:#f2f2f2;border:1px solid #ddd;word-wrap:break-word'>")
    html = html.replace("<td>", "<td style='padding:2px 4px;border:1px solid #eee;word-wrap:break-word'>")
    return html

# ========== ABRÉVIATIONS & COULEURS ==========
country_shortcuts = {
    "France":"FR","Italy":"IT","Spain":"ES","Portugal":"PT","Belgium":"BE",
    "Austria":"AT","Finland":"FI","Netherlands":"NL","Ireland":"IE","Slovakia":"SK","Slovenia":"SI",
    "Germany":"DE","Greece":"GR"
}
color_map = {
    "France":"#1f77b4","Italy":"#17becf","Spain":"#ff7f0e","Portugal":"#bcbd22",
    "Belgium":"#9467bd","Austria":"#d62728","Finland":"#2ca02c","Netherlands":"#e377c2",
    "Ireland":"#8c564b","Slovakia":"#7f7f7f","Slovenia":"#17b7cf"
}

# ========== SCATTER — (exactement ton algo) ==========
def _candidate_positions(pad=6):
    return [
        (0,+pad,'center','bottom'), (0,-pad,'center','top'),
        (+pad,0,'left','center'),   (-pad,0,'right','center'),
        (+pad,+pad,'left','bottom'),(-pad,+pad,'right','bottom'),
        (+pad,-pad,'left','top'),   (-pad,-pad,'right','top')
    ]

def _best_text_position(ax, x, y, text, taken_bboxes, all_xy,
                        pad=6, r_near=0.14, w_overlap=12.0, w_density=1.5, w_out=5.0):
    fig = ax.figure
    fig.canvas.draw()
    r = fig.canvas.get_renderer()
    xv, yv = all_xy[:,0], all_xy[:,1]
    x0, x1 = float(np.nanmin(xv)), float(np.nanmax(xv))
    y0, y1 = float(np.nanmin(yv)), float(np.nanmax(yv))
    xr, yr = max(x1-x0,1e-9), max(y1-y0,1e-9)
    x_n, y_n = (x-x0)/xr, (y-y0)/yr
    R2 = r_near**2

    best_score, best_bb, best_ann = float('inf'), None, None
    for dx,dy,ha,va in _candidate_positions(pad):
        ann = ax.annotate(text, (x,y), textcoords="offset points", xytext=(dx,dy),
                          ha=ha, va=va, fontsize=9)
        bb = ann.get_window_extent(renderer=r).expanded(1.03, 1.15)

        overlap_pen = sum(bb.overlaps(tb) for tb in taken_bboxes)

        m = np.ones_like(xv, dtype=bool)
        if dx!=0: m &= (np.sign(xv-x)==np.sign(dx)) | np.isclose(xv,x)
        if dy!=0: m &= (np.sign(yv-y)==np.sign(dy)) | np.isclose(yv,y)
        xn = (xv[m]-x0)/xr; yn = (yv[m]-y0)/yr
        density_pen = float(np.sum((xn-x_n)**2 + (yn-y_n)**2 <= R2))

        xl, yl = ax.get_xlim(), ax.get_ylim()
        out_pen = 1.0 if (x<xl[0] or x>xl[1] or y<yl[0] or y>yl[1]) else 0.0

        score = w_overlap*overlap_pen + w_density*density_pen + w_out*out_pen
        if score < best_score:
            if best_ann is not None: best_ann.remove()
            best_score, best_bb, best_ann = score, bb, ann
        else:
            ann.remove()

    taken_bboxes.append(best_bb)

def _df_to_scatter_points(df, key_col, dataset_name):
    carry_col = 'Carry' if 'Carry' in df.columns else 'CarrySpread'
    cols = [c for c in ['Country', key_col, 'Vol', carry_col] if c in df.columns]
    d = df[cols].copy().rename(columns={key_col:'Key', carry_col:'CarryVal'})
    d = d.dropna(subset=['Country','Key','Vol','CarryVal'])
    d = d[np.isfinite(d['Vol']) & np.isfinite(d['CarryVal'])]

    d = d[~d['Country'].isin(['Greece'])]
    if dataset_name in ('outright','curve_outright','fly_outright'):
        d = d[~d['Country'].isin(['Germany'])]

    d = d[(d['Vol'] > 0) & (d['Vol'].abs() < 1e5) & (d['CarryVal'].abs() <= 40)]

    def _lab(row):
        c = country_shortcuts.get(row['Country'], row['Country'][:2].upper())
        k = row['Key']
        try:
            if float(k).is_integer(): return f"{c} {int(float(k))}y"
        except Exception:
            pass
        return f"{c} {k}"
    d['Label'] = d.apply(_lab, axis=1)
    d['Color'] = d['Country'].map(color_map).fillna('black')

    d['CoV'] = d['CarryVal'] / d['Vol'].replace(0, np.nan)
    d = d.dropna(subset=['CoV'])
    return d

def _pick_top_for_country(df_pts, country, max_n=3, require_positive=True, prefer=(2,5,10,20)):
    sub = df_pts[df_pts['Country']==country].copy()
    if sub.empty: return sub
    sub['rankA'] = 2
    sub['rankB'] = 0.0
    def _rank_key(k):
        try:
            kk = float(k)
            return (0 if int(kk) in prefer else 1, abs(kk-10))
        except Exception:
            return (2, 0.0)
    rk = sub['Key'].apply(_rank_key)
    sub['rankA'] = [a for a,_ in rk]
    sub['rankB'] = [b for _,b in rk]
    if require_positive:
        pos = sub[sub['CarryVal'] > 0]
        if not pos.empty: sub = pos
    sub['absCoV'] = sub['CoV'].abs()
    sub = sub.sort_values(['rankA','rankB','absCoV'], ascending=[True, True, False])
    return sub.head(max_n).drop(columns=['rankA','rankB','absCoV'])

def _ensure_min_countries(selected, pool, min_countries=5,
                          prefer_order=('Spain','Portugal','Belgium','Austria','Finland','Netherlands','Ireland','Slovakia','Slovenia')):
    present = set(selected['Country'].unique())
    for c in prefer_order:
        if len(present) >= min_countries: break
        cand = pool[(pool['Country']==c) & (~pool.index.isin(selected.index)) & (pool['CarryVal']>0)]
        if not cand.empty:
            cand = cand.assign(absCoV=cand['CoV'].abs()).sort_values('absCoV', ascending=False).drop(columns='absCoV')
            pick = cand.iloc[[0]]
            selected = pd.concat([selected, pick], axis=0)
            present.add(c)
    return selected

def _grid_thinning(df_pts, must_keep_idx, grid=(18,11), max_per_cell=2, max_total=None, per_country_caps=None):
    if df_pts.empty: return df_pts
    x = df_pts['Vol'].values; y = df_pts['CarryVal'].values
    x0,x1 = np.nanmin(x), np.nanmax(x); y0,y1 = np.nanmin(y), np.nanmax(y)
    xr, yr = max(x1-x0,1e-6), max(y1-y0,1e-6)
    gx = np.clip(((x-x0)/xr*(grid[0]-1)).astype(int), 0, grid[0]-1)
    gy = np.clip(((y-y0)/yr*(grid[1]-1)).astype(int), 0, grid[1]-1)
    df = df_pts.copy(); df['_cell'] = list(zip(gx,gy))
    kept = set(must_keep_idx)
    caps = per_country_caps or {}
    df['absCoV'] = df['CoV'].abs()
    for cell, g in df[~df.index.isin(kept)].groupby('_cell'):
        g2 = g.sort_values('absCoV', ascending=False)
        taken = 0
        for idx,row in g2.iterrows():
            c = row['Country']
            if c in caps:
                already = sum(df.loc[list(kept)]['Country']==c)
                if already >= caps[c]: continue
            kept.add(idx)
            taken += 1
            if taken >= max_per_cell: break
    out = df.loc[sorted(kept)].drop(columns=['_cell','absCoV'])
    if (max_total is not None) and (len(out) > max_total):
        must = out.index.isin(must_keep_idx)
        rest = out[~must].copy()
        rest['absCoV'] = rest['CoV'].abs()
        rest = rest.sort_values('absCoV', ascending=False).drop(columns='absCoV')
        keep = list(out[must].index) + list(rest.index[:max_total - sum(must)])
        out = out.loc[keep]
    return out

def _select_points(points, dataset_name,
                   force_fr_it_min=3, min_countries=5, global_max_points=28, caps_extra=None):
    pts = points.copy()
    pts = pts[pts['CarryVal'] > 0]
    must_rows = []
    for c in ('France','Italy'):
        pick = _pick_top_for_country(pts, c, max_n=force_fr_it_min, require_positive=True)
        must_rows.append(pick)
    must = pd.concat(must_rows, axis=0) if must_rows else pd.DataFrame(columns=pts.columns)
    selected = _ensure_min_countries(must.copy(), pts, min_countries=min_countries)
    caps = {'Finland':3, 'Netherlands':3}
    if caps_extra: caps.update(caps_extra)
    pool = pts[~pts.index.isin(selected.index)]
    union = pd.concat([selected, pool], axis=0).drop_duplicates()
    cap = global_max_points if dataset_name in ('outright','spread') else max(20, global_max_points-6)
    thinned = _grid_thinning(union, must_keep_idx=selected.index.tolist(),
                             grid=(18,11), max_per_cell=2,
                             max_total=cap, per_country_caps=caps)
    thinned = _ensure_min_countries(thinned, pts, min_countries=min_countries)
    thinned['absCoV'] = thinned['CoV'].abs()
    thinned = thinned.sort_values(['Country','absCoV'], ascending=[True, False]).drop(columns='absCoV')
    return thinned

def _plot_scatter_generic(df, key_col, dataset_name, title, show_plot=True):
    pts = _df_to_scatter_points(df, key_col, dataset_name)
    if pts.empty:
        fig, ax = plt.subplots(figsize=(10.5, 6.5))
        ax.text(0.5, 0.5, "No data", ha='center', va='center')
        if show_plot: plt.show()
        return fig
    selected = _select_points(pts, dataset_name=dataset_name)
    fig, ax = plt.subplots(figsize=(10.5, 6.5))
    ax.axhline(0, color='grey', linewidth=0.8)
    ax.axvline(0, color='grey', linewidth=0.8)
    taken_bboxes = []
    xy = selected[['Vol','CarryVal']].to_numpy()
    for _, row in selected.iterrows():
        ax.plot(row['Vol'], row['CarryVal'], marker='D', markersize=8,
                linestyle='None', color=row['Color'])
        _best_text_position(ax, row['Vol'], row['CarryVal'], row['Label'],
                            taken_bboxes=taken_bboxes, all_xy=xy,
                            pad=6, r_near=0.14, w_overlap=12.0, w_density=1.5, w_out=5.0)
    countries = selected['Country'].unique().tolist()
    legend_elems = [Line2D([0],[0], marker='D', color='w',
                           markerfacecolor=color_map.get(c,'black'), markersize=8,
                           label=country_shortcuts.get(c,c)) for c in countries]
    ax.legend(handles=legend_elems, title="Country", loc='upper right', fontsize=9)
    ax.set_xlabel("Delivered vol (bp)")
    ax.set_ylabel("Carry (bp)")
    ax.set_title(title, pad=14)
    ax.grid(True, alpha=0.25)
    if show_plot: plt.tight_layout(); plt.show()
    else: plt.tight_layout()
    return fig

# Wrappers qui renvoient la figure (pas de plt.show()) :
def scatter_figure_outright(df_outright):
    return _plot_scatter_generic(df_outright, 'Maturity', 'outright',
                                 "Outright — Carry (y) vs Delivered Vol (x)", show_plot=False)
def scatter_figure_spread(df_spread):
    return _plot_scatter_generic(df_spread, 'Maturity', 'spread',
                                 "Spreads vs Germany — Carry (y) vs Delivered Vol (x)", show_plot=False)
def scatter_figure_box_outright(df_curve):
    return _plot_scatter_generic(df_curve, 'Box', 'curve_outright',
                                 "Curve Outright — Carry (y) vs Delivered Vol (x)", show_plot=False)
def scatter_figure_box_vs(df_box):
    return _plot_scatter_generic(df_box, 'Box', 'box',
                                 "Box vs Germany — Carry (y) vs Delivered Vol (x)", show_plot=False)
def scatter_figure_fly_outright(df_fly_out):
    return _plot_scatter_generic(df_fly_out, 'Fly', 'fly_outright',
                                 "Fly Outright — Carry (y) vs Delivered Vol (x)", show_plot=False)
def scatter_figure_fly_vs(df_fly_box):
    return _plot_scatter_generic(df_fly_box, 'Fly', 'fly_box',
                                 "Fly vs Germany — Carry (y) vs Delivered Vol (x)", show_plot=False)

# ========== CANDLESTICK — (ton rendu exact) ==========
def _draw_candles(ax, rows, x_key, x_is_bucket=True, title="Candlestick", xlabel="Maturity Buckets"):
    import numpy as np
    cols_num = ["Min","Max","Q25","Q50","Q75","Vol","CarryOverVol","CarryOneWeekAgo"]
    for c in cols_num:
        if c in rows.columns:
            rows[c] = pd.to_numeric(rows[c], errors="coerce")
    label_added = False
    if not x_is_bucket:
        cats = rows[x_key].astype(str).tolist()
        order = list(dict.fromkeys(cats))
        xpos = {lab: i+1 for i, lab in enumerate(order)}
        ax.set_xticks(list(xpos.values()))
        ax.set_xticklabels(order, rotation=0)
    else:
        xpos = None
    for _, row in rows.iterrows():
        vol = row.get('Vol', np.nan)
        if pd.isna(vol) or vol <= 0:
            continue
        x = row[x_key] if x_is_bucket else xpos[str(row[x_key])]
        min_val      = row['Min']  / vol if pd.notna(row['Min'])  else np.nan
        max_val      = row['Max']  / vol if pd.notna(row['Max'])  else np.nan
        q1_val       = row['Q25']  / vol if pd.notna(row['Q25'])  else np.nan
        q3_val       = row['Q75']  / vol if pd.notna(row['Q75'])  else np.nan
        median_val   = row['Q50']  / vol if pd.notna(row['Q50'])  else np.nan
        current_val  = row['CarryOverVol']
        one_week_val = row['CarryOneWeekAgo'] / vol if pd.notna(row['CarryOneWeekAgo']) else np.nan
        if any(pd.isna(v) for v in [min_val, max_val, q1_val, q3_val, median_val, current_val]):
            continue
        ax.plot([x, x], [min_val, max_val], color='black', marker='_', linewidth=2)
        ax.plot([x, x], [q1_val, q3_val], color='black', linewidth=8, alpha=0.5)
        ax.plot([x, x], [q1_val, q3_val], color='white', linewidth=6, alpha=1.0)
        ax.plot([x, x], [median_val, median_val], color='black', marker='_', markersize=6)
        ax.plot(x, current_val, color='red', marker='_', markersize=10,
                label='Current Value' if not label_added else "")
        if pd.notna(one_week_val):
            ax.plot(x, one_week_val, color='steelblue', marker='_', markersize=8,
                    label='1 Week ago' if not label_added else "")
        label_added = True
    ax.set_title(title)
    ax.set_ylabel("CarryOverVol")
    ax.set_xlabel(xlabel)
    ax.legend(loc='upper right')
    ax.grid(True)
    plt.tight_layout()

def _candlestick_by_country(df, key, x_is_bucket, title_fmt, xlabel, countries):
    figs = []
    d = df.copy()
    if key == 'Bucket' and 'Bucket' not in d.columns and 'Maturity' in d.columns:
        d = d.rename(columns={'Maturity':'Bucket'})
    if key == 'Bucket':
        d['Bucket'] = pd.to_numeric(d['Bucket'], errors='coerce')
    for c in countries:
        sub = d[(d.get('Country')==c) | (d.get('CountryPair')==f"{c}-Germany")].copy()
        if sub.empty: 
            continue
        fig, ax = plt.subplots(figsize=(12, 6))
        _draw_candles(ax, sub, x_key=key, x_is_bucket=x_is_bucket,
                      title=title_fmt.format(c=c), xlabel=xlabel)
        figs.append(fig)
    return figs

def candlestick_figs_outright(df_outright, countries=("France","Italy","Spain")):
    df = df_outright.copy()
    if 'Bucket' not in df.columns and 'Maturity' in df.columns:
        df = df.rename(columns={'Maturity':'Bucket'})
    df['Bucket'] = pd.to_numeric(df['Bucket'], errors='coerce')
    figs = []
    for c in countries:
        sub = df[(df['Country']==c) & (df['Bucket']>=2)].copy()
        if sub.empty: continue
        fig, ax = plt.subplots(figsize=(12, 6))
        _draw_candles(ax, sub, x_key='Bucket', x_is_bucket=True,
                      title=f"Candlestick-like Chart for {c}",
                      xlabel="Maturity Buckets")
        figs.append(fig)
    return figs

def candlestick_figs_spread(df_spread, countries=("France","Italy","Spain"), benchmark="Germany"):
    df = df_spread.copy()
    if 'Bucket' not in df.columns and 'Maturity' in df.columns:
        df = df.rename(columns={'Maturity':'Bucket'})
    figs = []
    for c in countries:
        pair = f"{c}-{benchmark}"
        sub = df[df['CountryPair']==pair].copy()
        if 'Bucket' in sub.columns:
            sub['Bucket'] = pd.to_numeric(sub['Bucket'], errors='coerce')
            sub = sub[sub['Bucket']>=2]
        if sub.empty: continue
        fig, ax = plt.subplots(figsize=(12, 6))
        _draw_candles(ax, sub, x_key='Bucket', x_is_bucket=True,
                      title=f"Candlestick-like Chart for {c}",
                      xlabel="Maturity Buckets")
        figs.append(fig)
    return figs

def candlestick_figs_box_outright(df_curve, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_curve[df_curve['Country']==c].copy()
        if sub.empty: continue
        fig, ax = plt.subplots(figsize=(12, 6))
        _draw_candles(ax, sub, x_key='Box', x_is_bucket=False,
                      title=f"Candlestick-like Chart for {c}", xlabel="Boxes")
        figs.append(fig)
    return figs

def candlestick_figs_box_vs(df_box, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_box[df_box['Country']==c].copy()
        if sub.empty: continue
        fig, ax = plt.subplots(figsize=(12, 6))
        _draw_candles(ax, sub, x_key='Box', x_is_bucket=False,
                      title=f"Candlestick-like Chart for {c}", xlabel="Boxes")
        figs.append(fig)
    return figs

def candlestick_figs_fly_outright(df_fly_out, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_fly_out[df_fly_out['Country']==c].copy()
        if sub.empty: continue
        fig, ax = plt.subplots(figsize=(12, 6))
        _draw_candles(ax, sub, x_key='Fly', x_is_bucket=False,
                      title=f"Candlestick-like Chart for {c}", xlabel="Flies")
        figs.append(fig)
    return figs

def candlestick_figs_fly_vs(df_fly_box, countries=("France","Italy","Spain")):
    figs=[]
    for c in countries:
        sub = df_fly_box[df_fly_box['Country']==c].copy()
        if sub.empty: continue
        fig, ax = plt.subplots(figsize=(12, 6))
        _draw_candles(ax, sub, x_key='Fly', x_is_bucket=False,
                      title=f"Candlestick-like Chart for {c}", xlabel="Flies")
        figs.append(fig)
    return figs

# ========== HTML helpers (structure 3 sections, 2 colonnes) ==========
def _col_html(title, table_html, scatter_img_html, cand_img_htmls):
    return f"""
    <div style="padding:10px">
      <div style="font:700 14px Arial;margin:0 0 6px 0">{title}</div>
      {table_html}
      {scatter_img_html}
      {''.join(cand_img_htmls)}
    </div>"""

def _two_col_row(left_html, right_html):
    return f"""
    <tr>
      <td valign="top" width="50%" style="width:50%;border-right:1px solid #e6e6e6">{left_html}</td>
      <td valign="top" width="50%" style="width:50%">{right_html}</td>
    </tr>"""

# ========== BUILD FIGS + TABLES ==========
def build_all_carry_figs_and_tables(
    best_outright, best_spread, best_curve, best_box, best_fly_out, best_fly_box,
    pivot_df_out, pivot_df_spread, pivot_df_curve, pivot_df_box, pivot_df_fly_out, pivot_df_fly_box,
    countries=("France","Italy","Spain")
):
    # scatters (tes filtres/couleurs/labels)
    fig_sc_out   = scatter_figure_outright(best_outright)
    fig_sc_sp    = scatter_figure_spread(best_spread)
    fig_sc_box_o = scatter_figure_box_outright(best_curve)
    fig_sc_box_v = scatter_figure_box_vs(best_box)
    fig_sc_fly_o = scatter_figure_fly_outright(best_fly_out)
    fig_sc_fly_v = scatter_figure_fly_vs(best_fly_box)

    # candlesticks (ton rendu)
    figs_out     = candlestick_figs_outright(best_outright, countries=countries)
    figs_spread  = candlestick_figs_spread(best_spread, countries=countries)
    figs_box_out = candlestick_figs_box_outright(best_curve, countries=countries)
    figs_box_vs  = candlestick_figs_box_vs(best_box, countries=countries)
    figs_fly_out = candlestick_figs_fly_outright(best_fly_out, countries=countries)
    figs_fly_vs  = candlestick_figs_fly_vs(best_fly_box, countries=countries)

    tables = dict(
        t_out     = _df_to_html_table(pivot_df_out,     caption="Pivot — Outright"),
        t_spread  = _df_to_html_table(pivot_df_spread,  caption="Pivot — Spread vs Germany"),
        t_box_out = _df_to_html_table(pivot_df_curve,   caption="Pivot — Curve Outright (Box)"),
        t_box_vs  = _df_to_html_table(pivot_df_box,     caption="Pivot — Box vs Germany"),
        t_fly_out = _df_to_html_table(pivot_df_fly_out, caption="Pivot — Fly Outright"),
        t_fly_vs  = _df_to_html_table(pivot_df_fly_box, caption="Pivot — Fly vs Germany"),
    )

    figs = dict(
        sc_out=fig_sc_out, sc_sp=fig_sc_sp,
        sc_box_o=fig_sc_box_o, sc_box_v=fig_sc_box_v,
        sc_fly_o=fig_sc_fly_o, sc_fly_v=fig_sc_fly_v,
        cand_out=figs_out, cand_sp=figs_spread,
        cand_box_o=figs_box_out, cand_box_v=figs_box_vs,
        cand_fly_o=figs_fly_out, cand_fly_v=figs_fly_vs,
    )
    return tables, figs

# ========== ENVOI ==========
def send_carry_email_using_your_vars(
    to_list,
    best_outright, best_spread, best_curve, best_box, best_fly_out, best_fly_box,
    pivot_df_out, pivot_df_spread, pivot_df_curve, pivot_df_box, pivot_df_fly_out, pivot_df_fly_box,
    sender="your.email@jpmorgan.com",
    subject="Carry Summaries",
    countries=("France","Italy","Spain")
):
    tables, figs = build_all_carry_figs_and_tables(
        best_outright, best_spread, best_curve, best_box, best_fly_out, best_fly_box,
        pivot_df_out, pivot_df_spread, pivot_df_curve, pivot_df_box, pivot_df_fly_out, pivot_df_fly_box,
        countries=countries
    )

    root = MIMEMultipart('related')
    root['Subject'] = subject
    root['From']    = sender
    root['To']      = ", ".join(to_list)
    alt  = MIMEMultipart('alternative')
    root.attach(alt)

    def add_img(fig, hint):
        cid, w, h = _fig_to_cid(root, fig, hint, px_width=_DEF_PX_W, aspect=_DEF_ASPECT, dpi=_DEF_DPI)
        return _img_tag(cid, w, h) if cid else ""

    sc_out_img   = add_img(figs['sc_out'],   "sc_out")
    sc_sp_img    = add_img(figs['sc_sp'],    "sc_sp")
    sc_box_o_img = add_img(figs['sc_box_o'], "sc_box_o")
    sc_box_v_img = add_img(figs['sc_box_v'], "sc_box_v")
    sc_fly_o_img = add_img(figs['sc_fly_o'], "sc_fly_o")
    sc_fly_v_img = add_img(figs['sc_fly_v'], "sc_fly_v")

    cand_out_imgs   = [add_img(f, f"cand_out_{i+1}")   for i,f in enumerate(figs['cand_out']   or [])]
    cand_sp_imgs    = [add_img(f, f"cand_sp_{i+1}")    for i,f in enumerate(figs['cand_sp']    or [])]
    cand_box_o_imgs = [add_img(f, f"cand_box_o_{i+1}") for i,f in enumerate(figs['cand_box_o'] or [])]
    cand_box_v_imgs = [add_img(f, f"cand_box_v_{i+1}") for i,f in enumerate(figs['cand_box_v'] or [])]
    cand_fly_o_imgs = [add_img(f, f"cand_fly_o_{i+1}") for i,f in enumerate(figs['cand_fly_o'] or [])]
    cand_fly_v_imgs = [add_img(f, f"cand_fly_v_{i+1}") for i,f in enumerate(figs['cand_fly_v'] or [])]

    left1  = _col_html("Outright",             tables['t_out'],    sc_out_img,   cand_out_imgs)
    right1 = _col_html("Spread vs Germany",    tables['t_spread'], sc_sp_img,    cand_sp_imgs)
    left2  = _col_html("Curve Outright (Box)", tables['t_box_out'], sc_box_o_img, cand_box_o_imgs)
    right2 = _col_html("Box vs Germany",       tables['t_box_vs'],  sc_box_v_img, cand_box_v_imgs)
    left3  = _col_html("Fly Outright",         tables['t_fly_out'], sc_fly_o_img, cand_fly_o_imgs)
    right3 = _col_html("Fly vs Germany",       tables['t_fly_vs'],  sc_fly_v_img, cand_fly_v_imgs)

    row1 = _two_col_row(left1, right1)
    row2 = _two_col_row(left2, right2)
    row3 = _two_col_row(left3, right3)

    intro = """
    <div style="font:13px Arial">
      Hello Team,<br><br>
      Please find below the Carry Analysis.<br><br>
    </div>
    """

    html_body = f"""
    <html>
      <body style="margin:0;padding:0;background:#fff">
        <center>
        <table role="presentation" cellspacing="0" cellpadding="0" border="0" width="1320"
               style="border-collapse:collapse;font:13px Arial">
          <tr><td colspan="2" style="padding:0 10px">{intro}</td></tr>

          <tr>
            <td colspan="2" style="font:700 16px Arial;padding:6px 10px;background:#f7f7f7;border-bottom:1px solid #e6e6e6">
              Outright (left) — vs Germany (right)
            </td>
          </tr>
          {row1}

          <tr><td colspan="2" style="height:14px"></td></tr>
          <tr>
            <td colspan="2" style="font:700 16px Arial;padding:6px 10px;background:#f7f7f7;border-bottom:1px solid #e6e6e6">
              Outright Curve (left) — Box vs Germany (right)
            </td>
          </tr>
          {row2}

          <tr><td colspan="2" style="height:14px"></td></tr>
          <tr>
            <td colspan="2" style="font:700 16px Arial;padding:6px 10px;background:#f7f7f7;border-bottom:1px solid #e6e6e6">
              Fly Outright (left) — Fly vs Germany (right)
            </td>
          </tr>
          {row3}
        </table>
        </center>
        <div style="height:12px"></div>
        <div style="font:11px Arial;color:#666;padding:0 10px">Generated automatically.</div>
      </body>
    </html>
    """

    alt.attach(MIMEText("Carry Summaries (HTML view required).", 'plain'))
    alt.attach(MIMEText(html_body, 'html'))

    smtp = smtplib.SMTP('mailhost.jpmchase.net')
    smtp.sendmail(sender, to_list, root.as_string())
    smtp.quit()

# =============================
# EXEMPLE D’APPEL — à adapter à tes variables existantes
# =============================
# send_carry_email_using_your_vars(
#     to_list=["team@jpmorgan.com"],
#     best_outright=best_outright,
#     best_spread=best_spread,
#     best_curve=best_curve,
#     best_box=best_box,
#     best_fly_out=best_fly_out,
#     best_fly_box=best_fly_box,
#     pivot_df_out=pivot_df_out,
#     pivot_df_spread=pivot_df_spread,
#     pivot_df_curve=pivot_df_curve,
#     pivot_df_box=pivot_df_box,
#     pivot_df_fly_out=pivot_df_fly_out,
#     pivot_df_fly_box=pivot_df_fly_box,
#     sender="your.email@jpmorgan.com",
#     subject="Carry Summaries"
# )



