# -*- coding: utf-8 -*-
# =========================================================
# Dash app — Carry & Carry/Vol (Time Series + CandleStick by Maturity, 126d lookback)
# =========================================================
from typing import Dict, Optional, List

import io, base64, socket, webbrowser
import numpy as np
import pandas as pd
import matplotlib
matplotlib.use("Agg")  # server/headless
import matplotlib.pyplot as plt

import dash
from dash import Dash, dcc, html, Input, Output, State, MATCH, ALL
import plotly.graph_objs as go

# =========================
# Try to locate required DataFrames
# =========================
# Expected in environment or data_loader:
# - data:       yields, columns "Country Matu" e.g. "France 10Y"
# - df_Swap:    ESTR swap curve, columns maturities: "1Y","2Y",...
# - df_Mod_Dur: Modified durations, same maturity columns
# - df_ESTR:    Single column (3M ESTR series)
# - df_Repo:    Repo rates by country, columns: "France","Germany","Italy","Spain"
def _try_get(name: str):
    try:
        return globals()[name]  # type: ignore[name-defined]
    except Exception:
        try:
            from data_loader import __dict__ as dl  # type: ignore
            return dl.get(name, None)
        except Exception:
            return None

data       = _try_get("data")
df_Swap    = _try_get("df_Swap")
df_Mod_Dur = _try_get("df_Mod_Dur")
df_ESTR    = _try_get("df_ESTR")
df_Repo    = _try_get("df_Repo")

# =========================
# Config
# =========================
AVAILABLE_COUNTRIES  = ["Germany", "Italy", "France", "Spain"]
AVAILABLE_MATURITIES = ["1Y","2Y","3Y","4Y","5Y","7Y","10Y","15Y","20Y","25Y","30Y"]
BUCKETS_NUM = [1,2,3,4,5,7,10,15,20,25,30]  # enforce same x-ticks across all candlesticks

MAX_SERIES = 10
DEFAULT_NUM_SERIES = 1

# Vol window (≈3M). Candlestick window fixed 126 trading days (≈6M).
WINDOW_3M     = 63
LOOKBACK_DAYS = 126

# =========================
# Helpers
# =========================
def ensure_dt_index(df: pd.DataFrame) -> pd.DataFrame:
    if not isinstance(df.index, pd.DatetimeIndex):
        df = df.copy()
        df.index = pd.to_datetime(df.index)
    return df.sort_index()

def slice_last_days(s: pd.Series, days: int) -> pd.Series:
    """Return last `days` observations; if fewer exist, return what's available."""
    s = s.dropna()
    if s.empty:
        return s
    return s.iloc[-int(days):].copy()

def matu_to_bucket(m: str) -> int:
    """Turn '10Y' -> 10, '1Y'->1, '25Y'->25 etc."""
    try:
        return int(str(m).upper().replace("Y","").strip())
    except Exception:
        return np.nan

def _series_yield(country: str, maturity: str) -> pd.Series:
    col = f"{country} {maturity}"
    if (data is None) or (col not in data.columns):
        raise KeyError(f"Yield column '{col}' not found in `data`.")
    return ensure_dt_index(data)[col].astype(float)

def _swap_estr(maturity: str) -> pd.Series:
    if (df_Swap is None) or (maturity not in df_Swap.columns):
        raise KeyError(f"Swap column '{maturity}' not found in `df_Swap`.")
    return ensure_dt_index(df_Swap)[maturity].astype(float)

def _mod_dur(maturity: str) -> pd.Series:
    if (df_Mod_Dur is None) or (maturity not in df_Mod_Dur.columns):
        raise KeyError(f"Modified duration '{maturity}' not found in `df_Mod_Dur`.")
    return ensure_dt_index(df_Mod_Dur)[maturity].astype(float)

def _repo(country: str) -> pd.Series:
    if (df_Repo is None) or (country not in df_Repo.columns):
        raise KeyError(f"Repo column '{country}' not found in `df_Repo`.")
    return ensure_dt_index(df_Repo)[country].astype(float)

def _estr3m_series() -> pd.Series:
    if (df_ESTR is None) or (df_ESTR.shape[1] < 1):
        raise KeyError("`df_ESTR` must have a single column with the 3M ESTR series.")
    return ensure_dt_index(df_ESTR).iloc[:, 0].astype(float)

# =========================
# Core carry/vol computations
# =========================
def compute_carry_3m(country: str, maturity: str) -> pd.Series:
    """
    Carry 3M daily time series (in bps):
      ((Yield - Swap(maturity) - (Repo(country) - ESTR_3M)) / (4 * ModifiedDuration(maturity))) * 100
    """
    y    = _series_yield(country, maturity)
    s    = _swap_estr(maturity)
    md   = _mod_dur(maturity).replace(0, np.nan)
    repo = _repo(country)
    estr3 = _estr3m_series()
    df = pd.concat({"yield": y, "swap": s, "mod_dur": md, "repo": repo, "estr3m": estr3}, axis=1).dropna()
    carry_bps = ((df["yield"] - df["swap"] - (df["repo"] - df["estr3m"])) / (4.0 * df["mod_dur"])) * 100.0
    carry_bps.name = f"{country} {maturity} Carry 3M (bps)"
    return carry_bps

def compute_vol_3m(country: str, maturity: str) -> pd.Series:
    """
    Rolling 3M volatility of yield daily changes (in bps/day):
      vol = std( Δ(yield% * 100) ) over 63 obs
    """
    y = _series_yield(country, maturity).dropna()
    dy = (y * 100.0).diff()
    vol = dy.rolling(WINDOW_3M, min_periods=WINDOW_3M//2).std()
    vol.name = f"{country} {maturity} Vol 3M (bps/day)"
    return vol

def compute_carry_over_vol(country: str, maturity: str) -> pd.Series:
    carry_bps = compute_carry_3m(country, maturity)
    vol       = compute_vol_3m(country, maturity)
    df        = pd.concat([carry_bps, vol], axis=1).dropna()
    cov       = df.iloc[:, 0] / df.iloc[:, 1].replace(0, np.nan)
    cov.name  = f"{country} {maturity} Carry/Vol"
    return cov

# =========================
# Matplotlib candlestick-like (YOUR format)
# =========================
def _to_png(fig) -> str:
    """Render Matplotlib figure to base64 PNG for embedding in Dash."""
    buf = io.BytesIO()
    fig.savefig(buf, format="png", bbox_inches="tight", dpi=160)
    plt.close(fig)
    buf.seek(0)
    return "data:image/png;base64," + base64.b64encode(buf.read()).decode("ascii")

# ---------- nucleus: draw a "candlestick" for a sub-table ----------
def _draw_candles(ax, rows, x_key, x_is_bucket=True, title="Candlestick", xlabel="Maturity Buckets"):
    """
    rows: DataFrame with columns:
          Min, Max, Q25, Q50, Q75, Vol, CarryOverVol, CarryOneWeekAgo, and x_key ('Bucket').
    x_is_bucket=True (numeric years) to align maturities.
    """
    import pandas as pd
    import numpy as np

    # -- Coerce numeric columns
    cols_num = ["Min","Max","Q25","Q50","Q75","Vol","CarryOverVol","CarryOneWeekAgo"]
    for c in cols_num:
        if c in rows.columns:
            rows[c] = pd.to_numeric(rows[c], errors="coerce")

    label_added = False

    # Force same X ticks across all charts for alignment
    ax.set_xticks(BUCKETS_NUM)
    ax.set_xticklabels([f"{b}Y" for b in BUCKETS_NUM], rotation=0)

    for _, row in rows.iterrows():
        vol = row.get('Vol', np.nan)
        if pd.isna(vol) or vol <= 0:
            continue

        x = int(row[x_key])  # bucket (year)

        # Y (ratios)
        min_val      = row['Min']  / vol if pd.notna(row['Min'])  else np.nan
        max_val      = row['Max']  / vol if pd.notna(row['Max'])  else np.nan
        q1_val       = row['Q25']  / vol if pd.notna(row['Q25'])  else np.nan
        q3_val       = row['Q75']  / vol if pd.notna(row['Q75'])  else np.nan
        median_val   = row['Q50']  / vol if pd.notna(row['Q50'])  else np.nan
        current_val  = row['CarryOverVol']  # already (carry/vol) or carry when Vol=1
        one_week_val = row['CarryOneWeekAgo'] / vol if pd.notna(row['CarryOneWeekAgo']) else np.nan

        if any(pd.isna(v) for v in [min_val, max_val, q1_val, q3_val, median_val, current_val]):
            continue

        # Whiskers min↔max
        ax.plot([x, x], [min_val, max_val], color='black', marker='_', linewidth=2)
        # Thick Q25–Q75
        ax.plot([x, x], [q1_val, q3_val], color='black', linewidth=8, alpha=0.5)
        ax.plot([x, x], [q1_val, q3_val], color='white', linewidth=6, alpha=1.0)
        # Median
        ax.plot([x, x], [median_val, median_val], color='black', marker='_', markersize=6)
        # Current (red)
        ax.plot(x, current_val, color='red', marker='_', markersize=10,
                label='Current Value' if not label_added else "")
        # One week ago (blue)
        if pd.notna(one_week_val):
            ax.plot(x, one_week_val, color='steelblue', marker='_', markersize=8,
                    label='1 Week ago' if not label_added else "")

        label_added = True

    ax.set_title(title)
    # y-label set by caller (carry vs ratio)
    ax.set_xlabel(xlabel)
    ax.legend(loc='upper right')
    ax.grid(True)
    plt.tight_layout()

def _rows_from_series_for_draw(series: pd.Series, vol_for_div: float,
                               current_ratio: float, one_week_ago_raw: float,
                               x_value, x_is_bucket=True) -> pd.DataFrame:
    """
    Build single-row for _draw_candles (one “candle” at bucket x_value).
    """
    s = series.dropna()
    if s.empty or not np.isfinite(vol_for_div) or vol_for_div <= 0:
        return pd.DataFrame(columns=["Bucket","Min","Max","Q25","Q50","Q75","Vol","CarryOverVol","CarryOneWeekAgo"])
    q = s.quantile([0.25, 0.5, 0.75])
    return pd.DataFrame([{
        "Bucket": int(x_value) if x_is_bucket else x_value,
        "Min": float(s.min()),
        "Max": float(s.max()),
        "Q25": float(q.loc[0.25]),
        "Q50": float(q.loc[0.5]),
        "Q75": float(q.loc[0.75]),
        "Vol": float(vol_for_div),
        "CarryOverVol": float(current_ratio),
        "CarryOneWeekAgo": float(one_week_ago_raw) if np.isfinite(one_week_ago_raw) else np.nan
    }])

# =========================
# Plotly helpers
# =========================
def fig_lines(series_dict: Dict[str, pd.Series], title: str, ylab: str) -> go.Figure:
    fig = go.Figure()
    for label, s in series_dict.items():
        s = s.dropna() if s is not None else pd.Series(dtype=float)
        if s.empty: continue
        fig.add_trace(go.Scatter(x=s.index, y=s.values, mode="lines", name=label))
    fig.update_layout(
        template="plotly_white",
        title=title,
        xaxis=dict(tickformat="%Y"),
        yaxis=dict(title=ylab),
        legend=dict(orientation="h", y=1.02, x=1, xanchor="right"),
        margin=dict(l=50, r=20, t=40, b=40)
    )
    return fig

# =========================
# App
# =========================
app: Dash = dash.Dash(__name__, suppress_callback_exceptions=True)
app.title = "Carry — Dash"

def _country_options():  return [{"label": c, "value": c} for c in AVAILABLE_COUNTRIES]
def _maturity_options(): return [{"label": m, "value": m} for m in AVAILABLE_MATURITIES]

app.layout = html.Div([
    html.H2("📈 Carry & Carry/Vol — Dashboard"),
    html.Div(id="warn-data", style={"color":"crimson", "marginBottom":"8px"}),

    # Top controls
    html.Div([
        html.Div([
            html.Label("How many series on the same chart?"),
            dcc.Dropdown(
                id="num-series",
                options=[{"label": str(i), "value": i} for i in range(1, MAX_SERIES+1)],
                value=DEFAULT_NUM_SERIES, clearable=False, style={"width":"220px"}
            ),
        ], style={"display":"inline-block","marginRight":"24px","verticalAlign":"top"}),

        html.Div(id="dynamic-pickers", style={"display":"inline-block","verticalAlign":"top"}),
    ], style={"marginBottom":"6px"}),

    # Formula notice
    html.Div([
        html.Span("Carry 3M formula (in bps): "),
        html.Code("((Yield − matched maturity ESTR swap − (Repo − ESTR 3M)) / (4 × Modified Duration)) × 100")
    ], style={"marginBottom":"10px","color":"#444"}),

    # Time series
    html.Div([
        html.Div([dcc.Graph(id="fig_carry",    config={"displaylogo": False})],
                 style={"width":"100%","display":"inline-block","marginBottom":"8px"}),
        html.Div([dcc.Graph(id="fig_carryvol", config={"displaylogo": False})],
                 style={"width":"100%","display":"inline-block"}),
    ]),

    html.Hr(),

    # ====== Candlesticks: aligned grid (independent from inputs) ======
    html.H3("CandleStick Plots — 6M History (126d) or Max Available"),
    html.Div("Each chart shows 11 maturities on X: 1Y,2Y,3Y,4Y,5Y,7Y,10Y,15Y,20Y,25Y,30Y."),
    # Use a clean, aligned grid
    html.Div(id="candles-grid", children=[
        # For each country, a two-column grid row; fixed image height for perfect alignment
        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity — Germany", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-carry", "country":"Germany"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity — Germany", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-cov",   "country":"Germany"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
        ], className="candles-row"),

        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity — Italy", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-carry", "country":"Italy"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity — Italy", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-cov",   "country":"Italy"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
        ], className="candles-row"),

        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity — France", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-carry", "country":"France"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity — France", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-cov",   "country":"France"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
        ], className="candles-row"),

        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity — Spain", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-carry", "country":"Spain"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity — Spain", style={"margin":"4px 0 8px 0"}),
                html.Img(id={"type":"mpl-cov",   "country":"Spain"},
                         style={"width":"100%","height":"420px","objectFit":"contain","display":"block","border":"1px solid #eee"})
            ]),
        ], className="candles-row"),
    ], style={
        "display":"grid",
        "rowGap":"16px"
    }),

    # hidden to trigger initial render of static candles
    html.Div(id="init-trigger", style={"display":"none"}),

    # Tiny CSS for the rows (2 equal columns, aligned)
    html.Style("""
        .candles-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            column-gap: 16px;
            align-items: stretch;
        }
    """),
])

# =========================
# Dynamic pickers (inputs section at top)
# =========================
@app.callback(
    Output("dynamic-pickers", "children"),
    Input("num-series", "value"),
)
def render_dynamic_pickers(n):
    n = int(n or 1)
    rows = []
    for i in range(1, n+1):
        rows.append(html.Div([
            html.Label(f"Series {i} — Country & Maturity"),
            dcc.Dropdown(id={"type":"country-dd", "index":i}, options=_country_options(),
                         placeholder=f"Country {i}", clearable=True, style={"width":"240px","display":"inline-block","marginRight":"8px"}),
            dcc.Dropdown(id={"type":"maturity-dd","index":i}, options=_maturity_options(),
                         placeholder=f"Maturity {i}", clearable=True, style={"width":"160px","display":"inline-block"}),
        ], style={"marginBottom":"6px"}))
    return rows

# =========================
# Time-series figures (use selectors)
# =========================
@app.callback(
    Output("fig_carry", "figure"),
    Output("fig_carryvol", "figure"),
    Output("warn-data", "children"),

    Input("num-series", "value"),
    Input({"type":"country-dd","index":ALL}, "value"),
    Input({"type":"maturity-dd","index":ALL}, "value"),
)
def update_timeseries(n, countries, maturities):
    empty = go.Figure(); empty.update_layout(template="plotly_white")
    if any(df is None for df in [data, df_Swap, df_Mod_Dur, df_ESTR, df_Repo]):
        return empty, empty, "Missing DataFrames. Provide `data`, `df_Swap`, `df_Mod_Dur`, `df_ESTR`, `df_Repo`."

    countries = countries or []
    maturities = maturities or []
    series_carry: Dict[str, pd.Series] = {}
    series_cov:   Dict[str, pd.Series] = {}

    for c, m in zip(countries, maturities):
        if not c or not m: continue
        label = f"{c} {m}"
        try:
            series_carry[label] = compute_carry_3m(c, m)
            series_cov[label]   = compute_carry_over_vol(c, m)
        except Exception:
            continue

    fig1 = fig_lines(series_carry, "Carry 3M over time", "Carry 3M (bps)")
    fig2 = fig_lines(series_cov,   "Carry/Vol 3M over time", "Carry/Vol (bps per bps/day)")
    return fig1, fig2, ""

# =========================
# Candlestick-like (per country) images — 11 maturities on X
# =========================
def _shift_business_days_to_past(s: pd.Series, n: int = 5) -> float:
    """Return the value n business days ago aligned on the series' last date."""
    s = s.dropna()
    if s.empty: return np.nan
    s_b = s.asfreq("B").ffill()
    last = s_b.index.max()
    v = s_b.shift(n).reindex([last]).iloc[0]
    return float(v) if np.isfinite(v) else np.nan

def _build_candle_rows_country(country: str):
    """
    Build two DataFrames (rows) for one country:
      - rows_carry: one row per maturity (Bucket=int years) using Carry 3M (bps), Vol=1
      - rows_cov:   one row per maturity using Carry/Vol ratio, Vol=1
    Each row uses up to last 126 obs (or fewer if not available).
    """
    rows_carry_list = []
    rows_cov_list   = []

    for m in AVAILABLE_MATURITIES:
        bucket = matu_to_bucket(m)
        if not np.isfinite(bucket):
            continue
        try:
            carry = compute_carry_3m(country, m)
            vol3m = compute_vol_3m(country, m)
            cov   = compute_carry_over_vol(country, m)
        except Exception:
            continue

        carry_win = slice_last_days(carry, LOOKBACK_DAYS)
        cov_win   = slice_last_days(cov,   LOOKBACK_DAYS)

        if carry_win.dropna().empty and cov_win.dropna().empty:
            continue

        latest_carry = float(carry.dropna().iloc[-1]) if not carry.dropna().empty else np.nan
        latest_cov   = float(cov.dropna().iloc[-1])   if not cov.dropna().empty   else np.nan

        carry_1w_raw = _shift_business_days_to_past(carry, n=5)
        vol_1w = _shift_business_days_to_past(vol3m, n=5) if not vol3m.dropna().empty else np.nan
        one_week_ratio = (carry_1w_raw / vol_1w) if (np.isfinite(carry_1w_raw) and np.isfinite(vol_1w) and vol_1w != 0) else np.nan

        if not carry_win.dropna().empty:
            rows_carry_list.append(
                _rows_from_series_for_draw(
                    series=carry_win, vol_for_div=1.0,
                    current_ratio=latest_carry, one_week_ago_raw=carry_1w_raw,
                    x_value=bucket, x_is_bucket=True
                )
            )
        if not cov_win.dropna().empty:
            rows_cov_list.append(
                _rows_from_series_for_draw(
                    series=cov_win, vol_for_div=1.0,
                    current_ratio=latest_cov, one_week_ago_raw=one_week_ratio,
                    x_value=bucket, x_is_bucket=True
                )
            )

    rows_carry = pd.concat(rows_carry_list, ignore_index=True) if rows_carry_list else pd.DataFrame(
        columns=["Bucket","Min","Max","Q25","Q50","Q75","Vol","CarryOverVol","CarryOneWeekAgo"]
    )
    rows_cov   = pd.concat(rows_cov_list,   ignore_index=True) if rows_cov_list   else pd.DataFrame(
        columns=["Bucket","Min","Max","Q25","Q50","Q75","Vol","CarryOverVol","CarryOneWeekAgo"]
    )

    if not rows_carry.empty:
        rows_carry = rows_carry.sort_values("Bucket")
    if not rows_cov.empty:
        rows_cov = rows_cov.sort_values("Bucket")
    return rows_carry, rows_cov

@app.callback(
    Output({"type":"mpl-carry","country":MATCH}, "src"),
    Output({"type":"mpl-cov",  "country":MATCH}, "src"),
    Input("init-trigger", "children"),
    State({"type":"mpl-carry","country":MATCH}, "id"),
)
def render_candles(_, id_state):
    if any(df is None for df in [data, df_Swap, df_Mod_Dur, df_ESTR, df_Repo]):
        blank = "data:image/png;base64,"
        return blank, blank

    ctry = id_state["country"]
    try:
        rows_carry, rows_cov = _build_candle_rows_country(ctry)
    except Exception:
        blank = "data:image/png;base64,"
        return blank, blank

    # Figure 1: Carry (bps)
    fig1, ax1 = plt.subplots(figsize=(12, 5.5))
    _draw_candles(ax1, rows_carry, x_key="Bucket", x_is_bucket=True,
                  title=f"CandleStick Carry vs Maturity — {ctry}",
                  xlabel="Maturity")
    ax1.set_ylabel("Carry 3M (bps)")
    img1 = _to_png(fig1)

    # Figure 2: Carry/Vol (ratio)
    fig2, ax2 = plt.subplots(figsize=(12, 5.5))
    _draw_candles(ax2, rows_cov, x_key="Bucket", x_is_bucket=True,
                  title=f"CandleStick Carry/Vol vs Maturity — {ctry}",
                  xlabel="Maturity")
    ax2.set_ylabel("Carry/Vol")
    img2 = _to_png(fig2)

    return img1, img2

# Trigger the static images once
@app.callback(Output("init-trigger", "children"), Input("num-series", "value"))
def trigger_init(_):
    return "ready"

# =========================
# Main
# =========================
if __name__ == "__main__":
    def get_local_ip():
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80)); ip = s.getsockname()[0]
        except Exception:
            ip = "127.0.0.1"
        finally:
            s.close()
        return ip

    host, port = "0.0.0.0", 8057
    local_ip = get_local_ip()
    print("\n================= SHARE THIS =================")
    print(f"Local (you) : http://localhost:{port}")
    print(f"LAN (team)  : http://{local_ip}:{port}")
    print("==============================================\n")
    try:
        webbrowser.open(f"http://localhost:{port}")
    except Exception:
        pass
    app.run_server(host=host, port=port, debug=False)
