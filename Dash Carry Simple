# -*- coding: utf-8 -*-
# =========================================================
# Dash app â€” Carry & Carry/Vol (Time Series + CandleStick by Maturity, 126d lookback)
# Comprehensive version with aligned candlestick grid and full helpers
# =========================================================
from typing import Dict, List, Tuple, Optional

# -------------------------
# Standard libraries
# -------------------------
import io
import base64
import socket
import webbrowser

# -------------------------
# Scientific stack
# -------------------------
import numpy as np
import pandas as pd

# Matplotlib (server/headless)
import matplotlib
matplotlib.use("Agg")
import matplotlib.pyplot as plt

# Plotly/Dash
import dash
from dash import Dash, dcc, html, Input, Output, State, MATCH, ALL
import plotly.graph_objs as go

# =========================================================
# 0) Data loading shim
# =========================================================
# We expect these DataFrames to exist in the env or be provided by data_loader.py:
#   - data:       yields       -> columns "Country Matu", e.g. "France 10Y"
#   - df_Swap:    ESTR swaps   -> columns maturities "1Y","2Y",... (floats)
#   - df_Mod_Dur: Modified Dur -> columns maturities "1Y","2Y",..., history of mod dur
#   - df_ESTR:    single column series for 3M ESTR
#   - df_Repo:    repo by country -> columns countries "France","Germany","Italy","Spain"
#
# All indices must be date-like. We coerce DatetimeIndex anyway.

def _try_get(name: str):
    """Try to read a global var; fallback to data_loader module dict; else None."""
    try:
        return globals()[name]  # type: ignore[name-defined]
    except Exception:
        try:
            from data_loader import __dict__ as dl  # type: ignore
            return dl.get(name, None)
        except Exception:
            return None

data       = _try_get("data")
df_Swap    = _try_get("df_Swap")
df_Mod_Dur = _try_get("df_Mod_Dur")
df_ESTR    = _try_get("df_ESTR")
df_Repo    = _try_get("df_Repo")

# =========================================================
# 1) Config
# =========================================================
AVAILABLE_COUNTRIES: List[str] = ["Germany", "Italy", "France", "Spain"]
AVAILABLE_MATURITIES: List[str] = ["1Y","2Y","3Y","4Y","5Y","7Y","10Y","15Y","20Y","25Y","30Y"]

# Fixed X ticks for candlestick alignment
BUCKETS_NUM: List[int] = [1,2,3,4,5,7,10,15,20,25,30]

# Dynamic time-series user selection
MAX_SERIES: int = 10
DEFAULT_NUM_SERIES: int = 1

# Vol window: 63 trading days (~3 months)
WINDOW_3M: int = 63

# Candlestick "6M" lookback in trading days
LOOKBACK_DAYS: int = 126

# Figure sizes for Matplotlib (identical to ensure alignment)
CANDLE_FIGSIZE: Tuple[float, float] = (12.0, 5.5)

# =========================================================
# 2) Helpers
# =========================================================
def ensure_dt_index(df: pd.DataFrame) -> pd.DataFrame:
    """Ensure DatetimeIndex and sorted by date ascending."""
    if not isinstance(df.index, pd.DatetimeIndex):
        df = df.copy()
        df.index = pd.to_datetime(df.index)
    return df.sort_index()

def slice_last_days(s: pd.Series, days: int) -> pd.Series:
    """
    Return last `days` observations (count-based). If fewer exist, return what's available.
    Robust to calendar gaps and holidays.
    """
    s = s.dropna()
    if s.empty:
        return s
    return s.iloc[-int(days):].copy()

def matu_to_bucket(m: str) -> int:
    """'10Y' -> 10, '1Y'->1, '25Y'->25; return int or np.nan if malformed."""
    try:
        return int(str(m).upper().replace("Y","").strip())
    except Exception:
        return np.nan

def _col_yield(country: str, maturity: str) -> str:
    """Build the column name in `data` for a given country & maturity."""
    return f"{country} {maturity}"

# =========================================================
# 3) Accessors for the provided DataFrames
# =========================================================
def _series_yield(country: str, maturity: str) -> pd.Series:
    """Yield series (float %). Column is 'Country Maturity' in `data`."""
    col = _col_yield(country, maturity)
    if (data is None) or (col not in data.columns):
        raise KeyError(f"Yield column '{col}' not found in `data`.")
    return ensure_dt_index(data)[col].astype(float)

def _swap_estr(maturity: str) -> pd.Series:
    """ESTR swap for given maturity (float %)."""
    if (df_Swap is None) or (maturity not in df_Swap.columns):
        raise KeyError(f"Swap column '{maturity}' not found in `df_Swap`.")
    return ensure_dt_index(df_Swap)[maturity].astype(float)

def _mod_dur(maturity: str) -> pd.Series:
    """Modified duration for given maturity (float)."""
    if (df_Mod_Dur is None) or (maturity not in df_Mod_Dur.columns):
        raise KeyError(f"Modified duration '{maturity}' not found in `df_Mod_Dur`.")
    return ensure_dt_index(df_Mod_Dur)[maturity].astype(float)

def _repo(country: str) -> pd.Series:
    """Repo series for given country (float %)."""
    if (df_Repo is None) or (country not in df_Repo.columns):
        raise KeyError(f"Repo column '{country}' not found in `df_Repo`.")
    return ensure_dt_index(df_Repo)[country].astype(float)

def _estr3m_series() -> pd.Series:
    """3M ESTR series (float %). Must be a single-column DataFrame."""
    if (df_ESTR is None) or (df_ESTR.shape[1] < 1):
        raise KeyError("`df_ESTR` must have a single column with the 3M ESTR series.")
    return ensure_dt_index(df_ESTR).iloc[:, 0].astype(float)

# =========================================================
# 4) Core calculations â€” Carry, Vol, Carry/Vol
# =========================================================
def compute_carry_3m(country: str, maturity: str) -> pd.Series:
    """
    Carry 3M daily time series (in bps):
      ((Yield - Swap(maturity) - (Repo(country) - ESTR_3M)) / (4 * ModifiedDuration(maturity))) * 100
    i.e., multiply by 100 at the end to express in basis points.
    """
    y     = _series_yield(country, maturity)     # %
    s     = _swap_estr(maturity)                 # %
    md    = _mod_dur(maturity).replace(0, np.nan)  # unitless (years)
    repo  = _repo(country)                       # %
    estr3 = _estr3m_series()                     # %

    df = pd.concat(
        {"yield": y, "swap": s, "mod_dur": md, "repo": repo, "estr3m": estr3},
        axis=1
    ).dropna()

    # Carry in bps
    carry_bps = ((df["yield"] - df["swap"] - (df["repo"] - df["estr3m"])) / (4.0 * df["mod_dur"])) * 100.0
    carry_bps.name = f"{country} {maturity} Carry 3M (bps)"
    return carry_bps

def compute_vol_3m(country: str, maturity: str) -> pd.Series:
    """
    Rolling 3M volatility of yield daily changes (in bps/day):
      vol = std( Î”(yield% * 100) ) over 63 obs
    """
    y = _series_yield(country, maturity).dropna()
    dy_bps = (y * 100.0).diff()
    vol = dy_bps.rolling(WINDOW_3M, min_periods=WINDOW_3M//2).std()
    vol.name = f"{country} {maturity} Vol 3M (bps/day)"
    return vol

def compute_carry_over_vol(country: str, maturity: str) -> pd.Series:
    """Carry/Vol ratio = (Carry 3M in bps) / (Vol 3M in bps/day)."""
    carry_bps = compute_carry_3m(country, maturity)
    vol_bps   = compute_vol_3m(country, maturity)
    df        = pd.concat([carry_bps, vol_bps], axis=1).dropna()
    cov       = df.iloc[:, 0] / df.iloc[:, 1].replace(0, np.nan)
    cov.name  = f"{country} {maturity} Carry/Vol"
    return cov

# =========================================================
# 5) Matplotlib â†” PNG helper
# =========================================================
def _to_png(fig) -> str:
    """Render Matplotlib figure to base64 PNG for embedding in Dash <img>."""
    buf = io.BytesIO()
    fig.savefig(buf, format="png", bbox_inches="tight", dpi=160)
    plt.close(fig)
    buf.seek(0)
    return "data:image/png;base64," + base64.b64encode(buf.read()).decode("ascii")

# =========================================================
# 6) Candlestick drawing utilities (your structure & look)
# =========================================================
def _draw_candles(
    ax: plt.Axes,
    rows: pd.DataFrame,
    title: str,
    xlabel: str,
    ylabel: str
) -> None:
    """
    Draws candlestick-like vertical markers across 'Bucket' (numeric years).
    'rows' is expected to include columns:
      ["Bucket","Min","Max","Q25","Q50","Q75","CarryOverVol","CarryOneWeekAgo"]
    with *already* the right scale (i.e., carry OR carry/vol ratio). No division inside.
    """
    # Fixed xticks for full alignment across all charts
    ax.set_xticks(BUCKETS_NUM)
    ax.set_xticklabels([f"{b}Y" for b in BUCKETS_NUM], rotation=0)

    # Iterate by maturity rows
    for _, row in rows.iterrows():
        b = row.get("Bucket", np.nan)
        if not np.isfinite(b):
            continue
        x = int(b)

        # Required values
        min_v = float(row.get("Min", np.nan))
        max_v = float(row.get("Max", np.nan))
        q25   = float(row.get("Q25", np.nan))
        q50   = float(row.get("Q50", np.nan))
        q75   = float(row.get("Q75", np.nan))
        curr  = float(row.get("CarryOverVol", np.nan))     # red line
        prev  = row.get("CarryOneWeekAgo", np.nan)         # blue line (optional)

        # Skip if essential stats are missing
        if any(np.isnan(v) for v in [min_v, max_v, q25, q50, q75, curr]):
            continue

        # Whiskers Minâ€“Max
        ax.plot([x, x], [min_v, max_v], color='black', linewidth=2)
        # Thick block Q25â€“Q75 (black under, white over)
        ax.plot([x, x], [q25, q75], color='black', linewidth=8, alpha=0.5)
        ax.plot([x, x], [q25, q75], color='white', linewidth=6, alpha=1.0)
        # Median
        ax.plot(x, q50, color='black', marker='_', markersize=6)
        # Current
        ax.plot(x, curr, color='red', marker='_', markersize=10, label="Current" if _ == 0 else "")
        # One week ago
        if pd.notna(prev):
            ax.plot(x, float(prev), color='steelblue', marker='_', markersize=8, label="1W ago" if _ == 0 else "")

    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    ax.legend(loc='upper right')
    ax.grid(True)
    plt.tight_layout()

def _rows_from_series_for_draw(
    series: pd.Series,
    x_bucket: int,
    current_value: float,
    one_week_ago_value: float
) -> pd.DataFrame:
    """
    Build a single-row DataFrame with distribution stats for the last LOOKBACK_DAYS
    (or fewer if not available). 'series' must already be in the target units:
      - Carry chart: series = Carry 3M in bps
      - Carry/Vol chart: series = Carry/Vol ratio
    """
    s = series.dropna()
    if s.empty:
        return pd.DataFrame(columns=["Bucket","Min","Max","Q25","Q50","Q75","CarryOverVol","CarryOneWeekAgo"])
    win = slice_last_days(s, LOOKBACK_DAYS)
    if win.empty:
        return pd.DataFrame(columns=["Bucket","Min","Max","Q25","Q50","Q75","CarryOverVol","CarryOneWeekAgo"])
    q = win.quantile([0.25, 0.5, 0.75])
    return pd.DataFrame([{
        "Bucket": int(x_bucket),
        "Min": float(win.min()),
        "Max": float(win.max()),
        "Q25": float(q.loc[0.25]),
        "Q50": float(q.loc[0.5]),
        "Q75": float(q.loc[0.75]),
        "CarryOverVol": float(current_value),
        "CarryOneWeekAgo": float(one_week_ago_value) if np.isfinite(one_week_ago_value) else np.nan
    }]])

def _shift_business_days_to_past(s: pd.Series, n: int = 5) -> float:
    """Value n business days before the last available business date (forward-filled)."""
    s = s.dropna()
    if s.empty:
        return np.nan
    sb = s.asfreq("B").ffill()
    last = sb.index.max()
    val = sb.shift(n).reindex([last]).iloc[0]
    return float(val) if np.isfinite(val) else np.nan

def _build_candlestick_tables_for_country(country: str) -> Tuple[pd.DataFrame, pd.DataFrame]:
    """
    For a given country, build two candlestick rows tables:
      - Carry (bps) by maturity
      - Carry/Vol (ratio) by maturity
    One row = one maturity bucket. Statistics computed over last 126 obs (or max available).
    """
    rows_carry_list: List[pd.DataFrame] = []
    rows_cov_list:   List[pd.DataFrame] = []

    for m in AVAILABLE_MATURITIES:
        bucket = matu_to_bucket(m)
        if not np.isfinite(bucket):
            continue
        try:
            carry_bps = compute_carry_3m(country, m)         # bps
            cov       = compute_carry_over_vol(country, m)   # ratio
        except Exception:
            # Skip missing/misaligned series
            continue

        # Latest values
        curr_carry = float(carry_bps.dropna().iloc[-1]) if not carry_bps.dropna().empty else np.nan
        curr_cov   = float(cov.dropna().iloc[-1])       if not cov.dropna().empty       else np.nan

        # One week ago values
        carry_1w   = _shift_business_days_to_past(carry_bps, n=5) if not carry_bps.dropna().empty else np.nan
        cov_1w     = _shift_business_days_to_past(cov,       n=5) if not cov.dropna().empty       else np.nan

        # Add carry row (if window has data)
        if not slice_last_days(carry_bps, LOOKBACK_DAYS).empty:
            rows_carry_list.append(
                _rows_from_series_for_draw(
                    series=carry_bps, x_bucket=int(bucket),
                    current_value=curr_carry, one_week_ago_value=carry_1w
                )
            )

        # Add carry/vol row (if window has data)
        if not slice_last_days(cov, LOOKBACK_DAYS).empty:
            rows_cov_list.append(
                _rows_from_series_for_draw(
                    series=cov, x_bucket=int(bucket),
                    current_value=curr_cov, one_week_ago_value=cov_1w
                )
            )

    rows_carry = pd.concat(rows_carry_list, ignore_index=True) if rows_carry_list else pd.DataFrame(
        columns=["Bucket","Min","Max","Q25","Q50","Q75","CarryOverVol","CarryOneWeekAgo"]
    )
    rows_cov   = pd.concat(rows_cov_list,   ignore_index=True) if rows_cov_list   else pd.DataFrame(
        columns=["Bucket","Min","Max","Q25","Q50","Q75","CarryOverVol","CarryOneWeekAgo"]
    )

    # Ensure ascending by Bucket for clean lines
    if not rows_carry.empty:
        rows_carry = rows_carry.sort_values("Bucket")
    if not rows_cov.empty:
        rows_cov = rows_cov.sort_values("Bucket")

    return rows_carry, rows_cov

# =========================================================
# 7) Plotly helpers (for time series section)
# =========================================================
def fig_lines(series_dict: Dict[str, pd.Series], title: str, ylab: str) -> go.Figure:
    """Build a simple multi-line time series figure."""
    fig = go.Figure()
    for label, s in series_dict.items():
        s = s.dropna()
        if s.empty:
            continue
        fig.add_trace(go.Scatter(x=s.index, y=s.values, mode="lines", name=label))
    fig.update_layout(
        template="plotly_white",
        title=title,
        xaxis=dict(tickformat="%Y"),
        yaxis=dict(title=ylab),
        legend=dict(orientation="h", y=1.02, x=1, xanchor="right"),
        margin=dict(l=50, r=20, t=40, b=40),
    )
    return fig

# =========================================================
# 8) Dash app layout
# =========================================================
app: Dash = dash.Dash(__name__, suppress_callback_exceptions=True)
app.title = "Carry â€” Dash"

def _country_options() -> List[dict]:
    return [{"label": c, "value": c} for c in AVAILABLE_COUNTRIES]

def _maturity_options() -> List[dict]:
    return [{"label": m, "value": m} for m in AVAILABLE_MATURITIES]

app.layout = html.Div([
    html.H2("ðŸ“ˆ Carry & Carry/Vol â€” Dashboard"),

    # Warning banner for missing data
    html.Div(id="warn-data", style={"color":"crimson","marginBottom":"8px"}),

    # Top selectors area
    html.Div([
        html.Div([
            html.Label("How many series on the same chart?"),
            dcc.Dropdown(
                id="num-series",
                options=[{"label": str(i), "value": i} for i in range(1, MAX_SERIES+1)],
                value=DEFAULT_NUM_SERIES,
                clearable=False,
                style={"width":"220px"}
            ),
        ], style={"display":"inline-block","verticalAlign":"top","marginRight":"24px"}),

        html.Div(id="dynamic-pickers", style={"display":"inline-block","verticalAlign":"top"}),
    ], style={"marginBottom":"6px"}),

    # Formula display
    html.Div([
        html.Span("Carry 3M formula (in bps): "),
        html.Code("((Yield âˆ’ matched maturity ESTR swap âˆ’ (Repo âˆ’ ESTR 3M)) / (4 Ã— Modified Duration)) Ã— 100")
    ], style={"marginBottom":"10px","color":"#444"}),

    # Time series section
    html.Div([
        html.Div([dcc.Graph(id="fig_carry",    config={"displaylogo": False})],
                 style={"width":"100%","display":"inline-block","marginBottom":"8px"}),
        html.Div([dcc.Graph(id="fig_carryvol", config={"displaylogo": False})],
                 style={"width":"100%","display":"inline-block"}),
    ]),

    html.Hr(),

    # Candlestick section (independent from inputs)
    html.H3("CandleStick Plots â€” 6M History (126d) or Max Available",
            style={"marginBottom":"6px"}),

    html.Div("Each chart shows 11 maturities on X: 1Y,2Y,3Y,4Y,5Y,7Y,10Y,15Y,20Y,25Y,30Y.",
             style={"marginBottom":"8px","color":"#555"}),

    # Grid of country rows; each row = 2 aligned columns (carry / carry-vol)
    html.Div(id="candles-grid", children=[
        # Germany row
        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity â€” Germany",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-carry", "country":"Germany"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity â€” Germany",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-cov",   "country":"Germany"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
        ], style={"display":"grid","gridTemplateColumns":"1fr 1fr","columnGap":"16px","alignItems":"stretch","marginBottom":"16px"}),

        # Italy row
        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity â€” Italy",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-carry", "country":"Italy"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity â€” Italy",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-cov",   "country":"Italy"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
        ], style={"display":"grid","gridTemplateColumns":"1fr 1fr","columnGap":"16px","alignItems":"stretch","marginBottom":"16px"}),

        # France row
        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity â€” France",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-carry", "country":"France"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity â€” France",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-cov",   "country":"France"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
        ], style={"display":"grid","gridTemplateColumns":"1fr 1fr","columnGap":"16px","alignItems":"stretch","marginBottom":"16px"}),

        # Spain row
        html.Div([
            html.Div([
                html.H4("CandleStick Carry vs Maturity â€” Spain",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-carry", "country":"Spain"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
            html.Div([
                html.H4("CandleStick Carry/Vol vs Maturity â€” Spain",
                        style={"margin":"4px 0 8px 0"}),
                html.Img(
                    id={"type":"mpl-cov",   "country":"Spain"},
                    style={"width":"100%","height":"420px","objectFit":"contain",
                           "display":"block","border":"1px solid #eee","backgroundColor":"#fff"}
                )
            ]),
        ], style={"display":"grid","gridTemplateColumns":"1fr 1fr","columnGap":"16px","alignItems":"stretch","marginBottom":"8px"}),

    ], style={"display":"grid","rowGap":"6px"}),

    # hidden trigger to render static images on load and when TS count changes
    html.Div(id="init-trigger", style={"display":"none"}),
])

# =========================================================
# 9) Dynamic pickers callback (top inputs)
# =========================================================
@app.callback(
    Output("dynamic-pickers", "children"),
    Input("num-series", "value"),
)
def render_dynamic_pickers(n):
    """Build N rows of (Country, Maturity) dropdowns for TS section."""
    try:
        n = int(n or 1)
    except Exception:
        n = 1
    rows = []
    for i in range(1, n+1):
        rows.append(html.Div([
            html.Label(f"Series {i} â€” Country & Maturity", style={"display":"block","marginBottom":"2px"}),
            dcc.Dropdown(id={"type":"country-dd", "index":i}, options=_country_options(),
                         placeholder=f"Country {i}", clearable=True,
                         style={"width":"240px","display":"inline-block","marginRight":"8px"}),
            dcc.Dropdown(id={"type":"maturity-dd","index":i}, options=_maturity_options(),
                         placeholder=f"Maturity {i}", clearable=True,
                         style={"width":"160px","display":"inline-block"}),
        ], style={"marginBottom":"6px"}))
    return rows

# =========================================================
# 10) Time-series figures callback
# =========================================================
@app.callback(
    Output("fig_carry", "figure"),
    Output("fig_carryvol", "figure"),
    Output("warn-data", "children"),

    Input("num-series", "value"),
    Input({"type":"country-dd","index":ALL}, "value"),
    Input({"type":"maturity-dd","index":ALL}, "value"),
)
def update_timeseries(n, countries, maturities):
    """Build the two TS charts from the user-selected series (up to 10)."""
    empty = go.Figure(); empty.update_layout(template="plotly_white")
    # Check data presence
    if any(df is None for df in [data, df_Swap, df_Mod_Dur, df_ESTR, df_Repo]):
        return empty, empty, "Missing DataFrames. Provide `data`, `df_Swap`, `df_Mod_Dur`, `df_ESTR`, `df_Repo`."

    countries = countries or []
    maturities = maturities or []
    series_carry: Dict[str, pd.Series] = {}
    series_cov:   Dict[str, pd.Series] = {}

    for c, m in zip(countries, maturities):
        if not c or not m:
            continue
        label = f"{c} {m}"
        try:
            series_carry[label] = compute_carry_3m(c, m)
            series_cov[label]   = compute_carry_over_vol(c, m)
        except Exception:
            # Skip series that cannot be constructed due to missing columns
            continue

    fig1 = fig_lines(series_carry, "Carry 3M over time", "Carry 3M (bps)")
    fig2 = fig_lines(series_cov,   "Carry/Vol 3M over time", "Carry/Vol (bps per bps/day)")
    return fig1, fig2, ""

# =========================================================
# 11) Candlestick images callback (per-country, independent of inputs)
# =========================================================
@app.callback(
    Output({"type":"mpl-carry","country":MATCH}, "src"),
    Output({"type":"mpl-cov",  "country":MATCH}, "src"),
    Input("init-trigger", "children"),
    State({"type":"mpl-carry","country":MATCH}, "id"),
)
def render_candles(_, id_state):
    """
    Render two aligned candlestick-like charts (Carry & Carry/Vol) for the requested country.
    Each chart has 11 buckets in X (1Y..30Y) with current & 1W-ago markers.
    """
    # Validate data presence
    if any(df is None for df in [data, df_Swap, df_Mod_Dur, df_ESTR, df_Repo]):
        blank = "data:image/png;base64,"  # empty data URL to avoid broken image
        return blank, blank

    ctry = id_state["country"]

    # Build the per-maturity stats tables
    try:
        rows_carry, rows_cov = _build_candlestick_tables_for_country(ctry)
    except Exception:
        blank = "data:image/png;base64,"
        return blank, blank

    # --- Figure 1: Carry (bps) ---
    fig1, ax1 = plt.subplots(figsize=CANDLE_FIGSIZE)
    if rows_carry.empty:
        # draw empty frame with title
        ax1.set_title(f"CandleStick Carry vs Maturity â€” {ctry}")
        ax1.set_xlabel("Maturity")
        ax1.set_ylabel("Carry 3M (bps)")
        ax1.set_xticks(BUCKETS_NUM); ax1.set_xticklabels([f"{b}Y" for b in BUCKETS_NUM])
        ax1.grid(True)
        plt.tight_layout()
    else:
        _draw_candles(ax1, rows_carry, title=f"CandleStick Carry vs Maturity â€” {ctry}",
                      xlabel="Maturity", ylabel="Carry 3M (bps)")
    img1 = _to_png(fig1)

    # --- Figure 2: Carry/Vol (ratio) ---
    fig2, ax2 = plt.subplots(figsize=CANDLE_FIGSIZE)
    if rows_cov.empty:
        ax2.set_title(f"CandleStick Carry/Vol vs Maturity â€” {ctry}")
        ax2.set_xlabel("Maturity")
        ax2.set_ylabel("Carry/Vol")
        ax2.set_xticks(BUCKETS_NUM); ax2.set_xticklabels([f"{b}Y" for b in BUCKETS_NUM])
        ax2.grid(True)
        plt.tight_layout()
    else:
        _draw_candles(ax2, rows_cov, title=f"CandleStick Carry/Vol vs Maturity â€” {ctry}",
                      xlabel="Maturity", ylabel="Carry/Vol")
    img2 = _to_png(fig2)

    return img1, img2

# Kick the static image render when number of TS series changes (or on load)
@app.callback(Output("init-trigger", "children"), Input("num-series", "value"))
def trigger_init(_):
    return "ready"

# =========================================================
# 12) Main
# =========================================================
if __name__ == "__main__":
    def get_local_ip() -> str:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        try:
            s.connect(("8.8.8.8", 80)); ip = s.getsockname()[0]
        except Exception:
            ip = "127.0.0.1"
        finally:
            s.close()
        return ip

    host, port = "0.0.0.0", 8057
    local_ip = get_local_ip()

    print("\n================= SHARE THIS =================")
    print(f"Local (you) : http://localhost:{port}")
    print(f"LAN (team)  : http://{local_ip}:{port}")
    print("==============================================\n")

    try:
        webbrowser.open(f"http://localhost:{port}")
    except Exception:
        pass

    app.run_server(host=host, port=port, debug=False)
